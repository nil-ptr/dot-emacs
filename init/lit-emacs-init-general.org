#+TITLE: Main Emacs Initialisation File
#+Author: Nils Gustafsson
#+OPTIONS: num:3 toc:nil
#+TAGS: { export(e) noexport(n) } { out_of_seq_keybind(O) actual_keybind_loc(A) }
#+PROPERTY: header-args :noweb no-export :tangle yes :exports code :comments link :padline true

General/misc package setup. In other words, this is where I configure
and load packages that don't fit in any other obvious
category. Imported by [[file:~/.emacs.d/init.el][init.el]].


* Imports and Prerequisites

  - I want lexical scoping here.

    #+NAME: lit-emacs-general-header
    #+BEGIN_SRC emacs-lisp -n -r -l ";(%s)" :comments no
    ;;; lit-emacs-init-general.el -*- lexical-binding: t -*-
    ;;; Commentary:
    ;;;
    ;;; Generated from lit-emacs-init-general.org
    #+END_SRC

  - This file needs access to the full =use-package= package when
    compiled. And I need =init-say= from my init macros.

    #+NAME: lit-emacs-general-imports
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (eval-when-compile
        (require 'use-package)
        (require 'my-init-macros)
        (def-init-say "init-general"))
    #+END_SRC

** Recompilation Code                                              :noexport:

   This code block may be evaluated to recompile and load this
   file. Useful to skip having to restart =emacs= to trigger
   recompilation.

   Note: This file currently has =:comments link= set. Take care if
   =org-id-link-to-org-use-id= is set to ~t~.

   #+BEGIN_SRC emacs-lisp :tangle no :exports none :noweb no :results value silent
     (let* ((this-file-base (expand-file-name "init/lit-emacs-init-general"
                                              user-emacs-directory))
            (this-file-org (concat this-file-base ".org"))
            (this-file-el  (concat this-file-base ".el"))
            (basebuf (or (buffer-base-buffer (current-buffer)) (current-buffer)))
            (tangled-file
             (progn
               (with-current-buffer basebuf (widen))
               (car
                (org-babel-tangle-file this-file-org
                                       this-file-el
                                       "emacs-lisp")))))
       (and (byte-compile-file tangled-file t)
            (format "Tangled, compiled, and loaded %s"
             tangled-file)))
   #+END_SRC

* Basic Emacs Initialisation

  Some basic things I need out of the way.

** A note for readers

   WRITTEN: [2019-05-08 ons]

   Some sections, such as [[*Indirect Buffers]], start with a list of key
   bindings for functions which are really defined in various
   locations throughout that section as a whole. These key bindings
   are displayed first, because they provide a nice quick overview of
   the main commands to be defined in the given section.

   The /actual/ site at which such a block is typically going to end
   up when source code is extracted from the original =org= file, is
   at the very end of the same section of the file. Sections with out
   of sequence key binding blocks in them are tagged with
   ~out_of_seq_keybind~ tags. The sections where these bindings
   /actually/ are not included when documentation is exported from
   this =org= file, but are tagged with ~actual_keybind_loc~ (and also
   ~noexport~) in the =org= source.



** Basic Window and Buffer Keys

   Firstly, some window-related stuff. I need a function to split the
   frame into three side-by-side windows, because that's my preferred
   default layout.

   #+NAME: lit-emacs-my-split-to-3-windows
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     (defun my-split-to-3-windows ()                                 ;(defNilguSplitwin)
       "Splits the current window until this frame has 3 and then balances them."
       (interactive)
       (let ((num (- 3 (count-windows))))
         (when (> num 0)
           (dotimes (_i num) (split-window-right nil))
           (balance-windows))))
   #+END_SRC

   And here are my global keys for window/buffer movment:

   #+NAME: lit-emacs-init-window-keybinds
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     ;; Window/buffer manipulation
     (use-package buffer-move
       :defer t
       :ensure t
       :bind (:map global-map
                   ("C-H-<left>"  . buf-move-left)
                   ("C-H-<right>" . buf-move-right)
                   ("C-H-<up>"    . buf-move-up)
                   ("C-H-<down>"  . buf-move-down)))
     (bind-keys
      :map global-map
      ("H-<left>"  . windmove-left)
      ("H-<right>" . windmove-right)
      ("H-<up>"    . windmove-up)
      ("H-<down>"  . windmove-down)
      ("C-x C-M-s" . my-split-to-3-windows)                         ;(splitwinBind)

      ;; Save, exit, and kill the server
      ("C-x C-M-c" . save-buffers-kill-emacs)                  ;(savebuffkillemacs)

      ;; Delete the current frame.
      ("H-q" . delete-frame)

      ;; Better keybinding for dabbrev-expand, as "M-\" is awkward on a
      ;; nordic keyboard.
      ("H-:"       . dabbrev-expand)

      ;; Useful command for basic code formatting. Especially for
      ;; struct/record layouts, list/map literals and the like.
      ("C-c a"     . align-regexp)                               ;(alignregexpBind)

      ;; Narrowing keys. See also my org settings.
      ("H-n n"     . narrow-to-region)
      ("H-n f"     . narrow-to-defun)
      ("H-n P"     . narrow-to-page)
      ;; Undo the narrowing.
      ("H-n w"     . widen))

   #+END_SRC

   Two noteworthy lines above are line [[(splitwinBind)]], in which I make
   use of [[(defNilguSplitwin)][my-split-to-3-windows]], and line [[(savebuffkillemacs)]] which sets up a
   binding for killing the current client /and/ the server.

   Additionally, there's a binding for [[(alignregexpBind)][align-regexp]], which is a handy
   tool to have for quick ad-hoc code formatting. Can be combined with
   a prefix argument. for a more powerful version of the command.

   A further note: the "H" in the keybindings above refers to the
   "Hyper" key, which is what I've reassigned capslock to. Because who
   even uses capslock?


** Narrowing and Pages

   The narrowing and page ideas in =emacs= are neat, but inserting
   form feed characters in to source code willy nilly makes me a
   little uncomfortable.

   So, based on the ideas in page.el, I'll implement my own substitutes.

*** =my-page-sep=: Definition

    First, let's define what my page separators even are:

    #+NAME: lit-emacs-init-page-sep-def
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (defvar my-page-sep-special-prefix nil
        "Special prefix to be used instead of `comment-start' in `my-page-sep'.

      Default value is nil, meaning no special prefix. This is the
      right choice in most modes.

      When this is non-nil it should be a string CONTAINING NO
      LINEBREAKS, and will replace the `comment-start' as the starting
      token for a `my-page-sep'. Setting it to a non-nil value also
      causes the end token of `my-page-sep' to be omitted entirely.")

      (eval-when-compile

        (defsubst my--page-sep-trim-start(s)
          (string-trim-left
           (if (< 0 (- (length s)
                       (length (string-trim-right s))))
               s
             (concat s " "))))

        ;; For §- (section separator)
        (defsubst my--page-sep-start-tok()
          (cond
           ;; Use the special prefix if it exists
           (my-page-sep-special-prefix
            (my--page-sep-trim-start my-page-sep-special-prefix))
           ;; If not, use comment-start
           (comment-start
            (my--page-sep-trim-start comment-start))
           ;; Use the empty string if it does not
            (t "")))


        (defsubst my--page-sep-end-tok()
          ;; 1. If my-page-sep-special-prefix is non-nil, ignore this token
          ;; completely.
          ;;
          ;; 2. I check for comment-start rather than comment-end here
          ;; because I don't know how I'd even begin to interpret what it
          ;; would mean for comment-end to be well defined when
          ;; comment-start is not.
          (if (and (not my-page-sep-special-prefix)
                   comment-start)
              (string-trim-right
               ;; Don't use comment-end if it's the empty string
               (if (and comment-end (not (string= comment-end "")))
                   (if (< 0 (- (length comment-end)
                               (length (string-trim-left comment-end))))
                       comment-end
                     (concat " " comment-end))
                 ;; If comment-end is nil or "" use a backwards start-tok
                 (reverse (my--page-sep-start-tok))))
            ;; Return an empty string if comment-start was nil
            ""))

        (defconst my--page-sep-center-tok
                "§ ────────── ────────── ────────── ────────── ──────────"))

      (defmacro my-page-sep-length()
        "Compute the length of the output of `my-page-sep'."
        `(+ (length (my--page-sep-start-tok))
            ,(length my--page-sep-center-tok)
            (length (my--page-sep-end-tok))))

      (defmacro my-page-sep()
        "My page separator token.

      See `insert-my-page-sep', `my-at-page-sep-p', `my-forward-page',
      `my-backward-page', and `my-narrow-to-page'."
        `(concat
          (my--page-sep-start-tok)
          ,my--page-sep-center-tok
          (my--page-sep-end-tok)))

    #+END_SRC

    The above snippet defines the separator and it's length as a pair
    of macros, since the exact value is going to depend on the local
    comment syntax.

    Next, I need some simple functions to insert and detect these:

    #+NAME: lit-emacs-init-page-sep-defuns
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      ;; TODO: allow trailing whitespace?
      (defun my-at-page-sep-p()
        "Return t if the current line contains a valid page separator.

      A valid page separator consists of a `comment-start' followed by
      a space (if needed), and the string \"§ ────────── ────────── ────────── ────────── ──────────\",
       followed by a space (if needed) and a `comment-end`, or, if
      `comment-end' is nil/empty, a reversed `comment-start'.

      If this explanation seems unclear, try invoking
      `my-insert-page-sep' to see an actual example."
        (save-excursion
          (beginning-of-line)
          (let ((sep (my-page-sep))
                (here (point))
                (there (progn (end-of-line) (point))))
            ;; Evaluates to nil if there is beyond the end of the buffer, or
            ;; the buffer-substring from here to there isn't the separator.
            (and (> (point-max) there)
                 (string= sep
                          (buffer-substring here
                                            there))))))
      (defun my-insert-page-sep()
        "Insert a page separator at the beginning of the current line.

      Any preexisting content on the line, including the cursor, is
      moved to the next line but is otherwise unchanged."
        (interactive)
        ;; Remember where we were, so we can move the point back to the same
        ;; column
        (let ((col (current-column)))
          (beginning-of-line)
          (insert (my-page-sep))
          (newline)
          (move-to-column col)))

      (defun my-count-lines-page()
        "Similar to `count-lines-page', but using `my-page-sep'.

      Displays the total number number of lines from the start of the
      current page up to the end of the current page. In parenthesis
      are:

      A. the number of lines from the start of the current page up to,
      but not including, the current line.
      B. the number one (representing the current line).
      C. the number of lines from the line following the current one to
      the end of the page.

      In other words the lines before point and lines after point will
      sum to 1 less than the number of lines in the page. So if the
      point is on the 4th line of a 5 line page, the output should look
      like this:

       \"Page has 5 (3 + 1 + 1) lines\".

      If the point is on a page separator, \"At page separator\" will
      be displayed instead.

      See `my-at-page-sep-p' for a simple description of what the
      separator looks like."
        (interactive)
        (if (my-at-page-sep-p)
            (message "At page separator")
          (save-excursion
            (let ((here (line-number-at-pos))                        ;(psepCountLines)
                  (bot (progn
                         (my-forward-page)
                         (when (my-at-page-sep-p)
                           (backward-char))
                         (line-number-at-pos)))
                  (top (progn
                         (my-backward-page)
                         (when (my-at-page-sep-p) (forward-line))
                         (line-number-at-pos) )))
              (message "Page has %d (%d + 1 + %d) lines"
                       (+ (- bot top) 1)
                       (- here top)
                       (- bot here))))))

      (bind-keys :map global-map
                 ("H-- -" . my-insert-page-sep)
                 ("H-- l" . my-count-lines-page))

    #+END_SRC

    I've elected to bind this to an available global binding, because
    I'll probably want to use it a lot.

    One thing worth noting in the above block is the use of
    =backward-char= and =forward-line= in the [[(psepCountLines)][let binding]] in
    =my-count-lines-page=, which is meant to exclude the page
    separators themselves. The exact same logic is going to show up in
    =my-narrow-to-page= in the next section, except there we also
    employ =forward-line= to exclude the starting page separator as
    well. Note also, that 1 is added to the "line total",

*** =my-page-sep=: Navigation and Narrowing

    So.. how /does/ one make use of these? By using them as anchors
    for navigation, and narrowing.

    In order to do that though, I need to define two basic primitives:
    #+NAME: lit-emacs-init-page-sep-nav-and-narrow-prim
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (eval-when-compile
        (defsubst my--to-next-page-sep-forward()
          (end-of-line)                                             ;(psepForwardEOL)
          (search-forward (my-page-sep) nil 'move)
          (while (not (or (eobp)
                          (my-at-page-sep-p)))
            (search-forward (my-page-sep) nil 'move))
          (beginning-of-line)                                       ;(psepForwardBOL)
          (point))

        (defsubst my--to-next-page-sep-backward()
          (search-backward (my-page-sep) nil 'move)
          (while (not (or (bobp)
                          (my-at-page-sep-p)))
            (search-backward (my-page-sep) nil 'move))
          (point)))
    #+END_SRC

    Note the use of [[(psepForwardEOL)][=end-of-line=]] and [[(psepForwardBOL)][=beginning-of-line=]]
    here. They're needed because =search-forward= with a non-nil-non-t
    3rd argument places the point /at the end of the match/, which is
    not where I want to be. To be specific, the =end-of-line= bit is
    there to compensate for the =beginning-of-line= bit which would
    cause a "movement loop" with =search-forward= if we're already at
    a page separator. The net result is a little bit of wasted
    movement work, but I don't think that matters much for a function
    that's almost exclusively going to be invoked by user input. The
    user won't notice the delay.

    =search-backward= already puts the point at the beginning of the
    match, so the corresponding shenanigans aren't necessary there.


    I can now define the actual user-facing "page forward" and "page
    backward" functions. I'm following the standard nomenclature used
    in =page.el= here: "forward-page" and "backward-page".

    #+NAME: lit-emacs-init-page-sep-nav
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"

      ;; mimics the forward-page function
      (defun my-forward-page(&optional count)
        "Move to the beginning of the first `my-page-sep' after point.
      If no page separator is found after point, move to the end of the
      buffer instead.

      With optional argument COUNT: repeat COUNT times. A negative
      COUNT is taken to mean \"move to the beginning of the previous\"
      `my-page-sep' instead.

      With a COUNT of 0, nothing is done.

      If called interactively, COUNT may be specified as a numeric prefix."
        (interactive "p")
        (setq count (or count 1))
        (if (< count 0)
            (while (and (< count 0) (not (bobp)))
              (setq count (1+ count))
              (my--to-next-page-sep-backward))
          (while (and (> count 0) (not (eobp)))
            (setq count (1- count))
            (my--to-next-page-sep-forward))))

      ;; mimics the backward-page function
      (defun my-backward-page(&optional count)
        "Move to the beginning of the first `my-page-sep' before point.
      If no page separator is found before point, move to the beginning
      of the buffer instead.

      This function is exactly identical to `my-forward-page' with a
      negative argument."
        (interactive "p")
        (setq count (or count 1))
        (my-forward-page (- count)))                                    ;(myBackPage)

    #+END_SRC

    Nothing all that noteworthy about these definitions, aside from
    =my-backward-page= being pretty much just an [[(myBackPage)][alias for
    =my-forward-page=]] with a negative argument.

    Having done that, we define a narrowing function using my page
    separators.

    #+NAME: lit-emacs-init-page-sep-narrow
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"

      ;; Narrowing!
      (defun my-narrow-to-page()
        "Like `narrow-to-page', but using `my-page-sep'.

      See `my-at-page-sep-p' for a simple description of what the
      separators look like.

      Briefly: This function finds the next page separator after point,
      then the first page separator preceding that one, and invokes
      `narrow-to-region' to narrow the buffer to everything between
      those two separators apart from the separators themselves."
        (interactive)
        (save-excursion
          (my-forward-page)
          (when (not (eobp))
            ;; go back one char, to reach the end of the previous line
            (backward-char))
          (narrow-to-region
           (point)
           (progn
             (my-backward-page)
             (when (not (bobp))
               ;; go to the next line (we're already at the left margin)
               (forward-line))
             (point)))))

    #+END_SRC


    And versions of =my-forward-page= and =my-backward-page= that
    widen and then narrow to the arrived at page.

    #+NAME: liet-emacs-init-page-sep-narrow-nav
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (defun my-forward-narrow-page (&optional count)
        "Like `my-forward-page', except it narrows to the target page.

      Additionally it will widen the current buffer before
      moving, COUNT is treated the same way as it is in
      `my-forward-page'."
        (interactive "p")
        (widen)
        (setq count (or count 1))
        (my-forward-page count)
        (my-narrow-to-page))

      (defun my-backward-narrow-page (&optional count)
        "Like `my-backward-page' except it narrows to the target page.

      Additionally it will widen the current buffer before
      moving, COUNT is treated the same way as it is in
      `my-backward-page'."
        (interactive "p")
        (widen)
        (setq count (or count 1))
        ;; An extra + 1 is needed here, for us to narrow to the correct
        ;; page.
        (my-backward-page (+ 1 count))                             ;(backwardsOffset)
        (my-narrow-to-page))
    #+END_SRC

    A note regarding [[(backwardsOffset)]]: =my-backward-page= moves to
    the beginning of the /current/ page, or if we're already there the
    beginning of the page before that. But moving to the beginning of
    the current page and re-narrowing would be unhelpful. Thus we move
    an extra page backwards, so that it really always tries to narrow
    to the page /before/ the current one.


    Lastly, let's bind these things to some keys.

    #+NAME: lit-emacs-init-page-sep-bind-keys
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      ;; Bind some keys
      (bind-keys :map global-map
                 ;; next/prior is page up / page down
                 ("H-<next>" . my-forward-page)
                 ("H-<prior>" . my-backward-page)
                 ("C-H-<next>" . my-forward-narrow-page)
                 ("C-H-<prior>" . my-backward-narrow-page)
                 ;; Mirrors the binding for narrow-to-page.
                 ("H-n p" . my-narrow-to-page)
                 ;; Is consistent with "H-- -" and "H-- l" defined earlier.
                 ("H-- n" . my-narrow-to-page))
    #+END_SRC


** Indirect Buffers                                      :out_of_seq_keybind:

   WRITTEN: [2019-05-08 ons]

   Another interesting bit of functionality in =emacs= is the notion
   of an indirect buffer. In this section I define some nice helpers
   and a few hooks to make indirect buffers a little easier to make
   and use.


   #+HEADER: Commands defined in this section
   #+NAME: lit-emacs-indirect-buffer-key-binds
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :tangle no
     (bind-keys
      :map global-map

      ;; Clone the current buffer and switch to the clone.
      ("H-b c" . my-clone-indirect-buffer)

      ;; Make the current view unique.
      ("H-b u" . my-make-current-view-unique)

      ;; Switch to a different buffer with the same base buffer.
      ("H-b b" . my-switch-to-buffer-with-base-buffer-of)

      ;; Kill the base buffer of the current buffer.
      ("H-b K" . my-kill-base-buffer)
      ;; Switch to the base of the current buffer and kill all indirect
      ;; buffers.
      ("H-b k" . my-kill-indirect-buffers-of))
   #+END_SRC

*** Primitives

    Let's start off with some low level primitives.

    #+NAME: lit-emacs-indirect-buffer-compile-primitives
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (eval-when-compile
        (defsubst my--get-base-buffer-of-buffer (&optional buffer)
      <<my--get-base-buffer-of-buffer-doc-string>>
          (or (buffer-base-buffer
               (or buffer
                   (current-buffer)))
              buffer))

        (defsubst my--get-buffer (&optional buffer-or-name)
      <<my--get-buffer-doc-string>>
          (get-buffer
           (or buffer-or-name
               (current-buffer))))

        (defsubst my--get-buffer-or-err (&optional buffer-or-name)
      <<my--get-buffer-or-err-doc-string>>
          (or (my--get-buffer buffer-or-name)
              (error "No such buffer: %s" buffer-or-name)))

        (defsubst my--get-base-buffer (&optional buffer-or-name)
      <<my--get-base-buffer-doc-string>>
          (my--get-base-buffer-of-buffer
           (my--get-buffer buffer-or-name)))

        (defsubst my--base-buffer-is-p (base buffer)
      <<my--base-buffer-is-p-doc-string>>
            (eq (my--get-base-buffer buffer) base)))
    #+END_SRC

    #+NAME: my--get-base-buffer-of-buffer-doc-string
    #+BEGIN_SRC emacs-lisp :exports none :tangle no
              "Returns the base buffer of BUFFER.

      If BUFFER is not an indirect buffer, return BUFFER.

      If BUFFER is omitted or nil, return the base buffer of the
      current buffer.

      The return value from this function is always a buffer object."
    #+END_SRC

    #+NAME: my--get-buffer-doc-string
    #+BEGIN_SRC emacs-lisp :exports none :tangle no
              "Return the buffer named BUFFER-OR-NAME.

      BUFFER-OR-NAME must be a string or a buffer.

      If BUFFER-OR-NAME is a string and there is no buffer named
      BUFFER-OR-NAME, return nil.

      If BUFFER-OR-NAME is a buffer, return BUFFER-OR-NAME.

      If BUFFER-OR-NAME is omitted or nil, return the current buffer.

      This function is equivalent to `get-buffer' except the
      BUFFER-OR-NAME argument is optional."
    #+END_SRC

    #+NAME: my--get-buffer-or-err-doc-string
    #+BEGIN_SRC emacs-lisp :exports none :tangle no
              "Return the buffer named BUFFER-OR-NAME.

      BUFFER-OR-NAME must be a string or a buffer.

      If BUFFER-OR-NAME is a string and there is no buffer named
      BUFFER-OR-NAME, raise an error.

      If BUFFER-OR-NAME is a buffer, return BUFFER-OR-NAME.

      If BUFFER-OR-NAME is omitted or nil, return the current buffer.

      The return value from this function is always a buffer object, if
      it returns normally."
    #+END_SRC

    #+NAME: my--get-base-buffer-doc-string
    #+BEGIN_SRC emacs-lisp :exports none :tangle no
          "Return the base buffer of BUFFER-OR-NAME.

      If BUFFER-OR-NAME is not an indirect buffer, return the buffer
      corresponding to BUFFER-OR-NAME.

      If BUFFER-OR-NAME is a string and there is no buffer named
      BUFFER-OR-NAME, raise an error.

      If BUFFER-OR-NAME is omitted or nil, return the base buffer of
      the current buffer.

      The return value from this function is always a buffer object, if
      it returns normally."
    #+END_SRC

    #+NAME: my--base-buffer-is-p-doc-string
    #+BEGIN_SRC emacs-lisp :exports none :tangle no
          "Return non-nil if BASE is the base buffer of BUFFER.

      Both arguments must be actual buffers."
    #+END_SRC


    All four of the functions above are in scope only during
    compilation, making them useless outside of this file. They're
    really only here to make other definitions a little easier on the
    eyes. The documentation strings are included in the source, but
    excluded from export, in the interest of making this code block
    less noisy.

    Next, lets define some basic helper functions.

    - =my-buffer-list-with-base-buffer-of=

      Fetches all buffers that share their base buffer with the given
      one.

      #+HEADER: =my-buffer-list-with-base-buffer-of=
      #+NAME: lit-emacs-my-indirect-buffer-primitives-buffer-list-with-base
      #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
        (defun my-buffer-list-with-base-buffer-of (&optional buffer-or-name predicate)
          "Return all buffers that share their base buffer with BUFFER-OR-NAME.

        BUFFER-OR-NAME must be a string or a buffer.

        If BUFFER-OR-NAME is omitted of nil, `current-buffer' will be
        used instead.

        If BUFFER-OR-NAME is a buffer, this will always return a
        non-empty list.  BUFFER-OR-NAME is by definition one of the
        buffers with the same base buffer as BUFFER-OR-NAME.

        If BUFFER-OR-NAME is a string and a buffer by that name exists,
        the list of buffers with the same base buffer as that buffer is
        returned.

        If BUFFER-OR-NAME is a string that does not correspond to the
        name of an existing buffer, this function returns nil.

        In addition, an optional PREDICATE may be supplied to further
        filter the list of buffers returned.  Buffers for which the
        PREDICATE is non-nil will be omitted."
          (let ((buf (my--get-buffer buffer-or-name)))
            (when buf
              (let ((base-buf (my--get-base-buffer-of-buffer buf)))
                (seq-filter
                 #'(lambda(b)
                     (let ((other-buf (my--get-buffer b)))
                       (and (my--base-buffer-is-p base-buf other-buf)
                            (if predicate (apply predicate (list other-buf)) t))))
                 (buffer-list))))))
      #+END_SRC

      This function returns a list containing all buffers that share
      their base buffer with the given one. If called with no
      argument, it will list all buffers that share a base buffer with
      the current buffer.

      If no ~predicate~ is supplied, then the returned list is always
      non-empty: it /must/ contain the argument buffer.

      If the ~buffer-or-name~ argument is a string that does not match
      the name of an existing buffer, ~nil~ is returned.

    - =my-indirect-buffer-list-with-base-buffer-of=

      Fetches all /indirect/ buffers that share their base buffer with
      the given one.

      #+HEADER: =my-indirect-buffer-list-with-base-buffer-of=
      #+NAME: lit-emacs-my-indirect-buffer-primitives-indirect-buffers-of
      #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
        (defun my-indirect-buffer-list-with-base-buffer-of (&optional buffer-or-name predicate)
          "Return a list of all indirect buffers related to BUFFER-OR-NAME.

        BUFFER-OR-NAME must be a string or a buffer.

        If BUFFER-OR-NAME is an indirect buffer, all indirect buffers
        with the same base buffer as BUFFER-OR-NAME are returned.  This
        includes BUFFER-OR-NAME itself.

        If BUFFER-OR-NAME is not an indirect buffer, all indirect buffers
        with base buffer BUFFER-OR-NAME are returned.  This list will be
        nil, if there are no such indirect buffers.

        If BUFFER-OR-NAME is omitted or nil, the current buffer will be
        used instead.

        If BUFFER-OR-NAME is a string that is not the name of an existing
        buffer, return nil.

        In addition, an optional PREDICATE may be supplied to further
        filter the list of buffers returned.  Buffers for which the
        PREDICATE is non-nil will be omitted.

        Note: Keep in mind that there are two distinct ways for this
        function to return nil if BUFFER-OR-NAME is a string and
        PREDICATE is nil.  Do not use the return value of this function
        in if/where/unless clauses unless you're sure what that actually
        means."
          (let ((buf (my--get-buffer buffer-or-name)))
            ;; We could do something like this:
            ;;
            ;;(seq-remove #'(lambda (b) (eq b basebuf))
            ;;            (my-buffer-list-with-base-buffer-of basebuf))
            ;;
            ;; But why traverse the list twice?
            (when buf
              (let ((base-buf (my--get-base-buffer-of-buffer buf)))
                (my-buffer-list-with-base-buffer-of
                 buf
                 #'(lambda (b)
                       (let ((other-buf (my--get-buffer b)))
                         (and (not (eq base-buf other-buf))
                              (if predicate
                                  (apply predicate (list other-buf)) t)))))))))
      #+END_SRC

      This function returns a list containing all indirect buffers that
      share their base buffer with the given one. If called with no
      argument, it computes the list of indirect buffers that share a
      base buffer with the current buffer.

      If no ~predicate~ is supplied, then the resulting list will
      include the argument buffer if the argument buffer was an
      indirect buffer.

      As the documentation string notes, one potential point of
      confusion is that there are two distinct reasons why this
      function may have returned ~nil~, given a string argument and no
      ~predicate~.

      It could be that the string didn't match any existing buffer, or
      it could be that the buffer existed but that the list of
      indirect buffers based on it is ~nil~.

      The ambiguity can be avoided entirely if the argument is an
      actual buffer instead of just a name. Calling it with a ~nil~
      argument, or no argument, is also unambiguous.

      With a non-nil ~predicate~, all bets are off.

*** Creation

    Before we define a way to create indirect buffers (beyond the
    =emacs= built-ins), let's define some convenient hooks.

    #+HEADER: My Indirect Buffer Hooks
    #+NAME: lit-emacs-my-clone-indirect-buffer-hooks
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (defun my--living-clones-kill-buffer-query-fun ()
        "Display a warning prompt about indirect buffers of the current buffer.

      For use with `kill-buffer-query-functions'.  Should not need to
      be called directly.  Nor should it need to be added or removed
      manually."
        (let ((buf (current-buffer)))
          (or
           (null (my-indirect-buffer-list-with-base-buffer-of buf))
           (y-or-n-p
            (concat "There appear to be live indirect buffers using"
                    (format " buffer %s as a base. Really kill it?"
                            buf))))))

      (defun my--clean-up-indirect-buffer-clone-hooks-hook()
        "Used in `my-clone-indirect-buffer'.

      Locally deletes itself from `clone-indirect-buffer-hook', and
      deletes `my--living-clones-kill-buffer-query-fun' from
      `kill-buffer-query-functions' when run.

      Should not need to be called or added/removed manually."
        (remove-hook 'kill-buffer-query-functions
                     #'my--living-clones-kill-buffer-query-fun
                     t)
        (remove-hook 'clone-indirect-buffer-hook
                     #'my--clean-up-indirect-buffer-clone-hooks-hook ;(selfCleanUpHook)
                     t))
    #+END_SRC

    The first hook adds an extra prompt to the affected buffer if that
    buffer has any indirect buffers when the user tries to kill it.

    The second hook deletes the first hook when present in a newly
    cloned indirect buffer. And it deletes itself: note the
    self-referentiality of line [[(selfCleanUpHook)]].

    Armed with those hooks we can define =my-clone-indirect-buffer=.

    #+HEADER: =my-clone-indirect-buffer=
    #+NAME: lit-emacs-my-clone-indirect-buffer
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (defun my-clone-indirect-buffer (newname display &optional norecord)
        "Clone the current buffer and then display the clone in the current window.

      The new indirect buffer will be named NEWNAME, or will be
      generated by `clone-indirect-buffer' if nil was supplied.  When
      called interactively with a prefix argument, prompt for NEWNAME
      using the minibuffer.  Without a prefix argument, behave as if
      NEWNAME was nil.

      If DISPLAY is 'switch, he newly created buffer is displayed in
      the current window using `switch-to-buffer'.  This is always the
      case when called interactively.  Any other non-nil value of
      DISPLAY will display the buffer using `pop-to-buffer'.

      If NORECORD is non-nil, do not put this at the front of the list of
      recently selected buffers.

      The new buffer is returned.

      This function mimics `clone-indirect-buffer', but with slightly
      different DISPLAY related behaviour.  In addition it adds
      `my--living-clones-kill-buffer-query-fun' and
      `my--clean-up-indirect-buffer-clone-hooks-hook' to the
      `kill-buffer-query-functions' and `clone-indirect-buffer-hook'
      hook lists."
        (interactive
         ;; logic borrowed from clone-indirect-buffer           ;(cloneBufferArgParse)
         (progn
           (if (get major-mode 'no-clone-indirect)
               (error "Cannot indirectly clone a buffer in %s mode" mode-name))
           (list
            (when current-prefix-arg
              (read-buffer "Name of new indirect buffer: " (current-buffer)))
            'switch)))
        (with-current-buffer (my--get-base-buffer)          ;(myCloneIndInstallHooks)
          (add-hook 'kill-buffer-query-functions
                    #'my--living-clones-kill-buffer-query-fun
                    nil
                    t)
          (add-hook 'clone-indirect-buffer-hook
                    #'my--clean-up-indirect-buffer-clone-hooks-hook
                    nil
                    t))
        (let ((newbuf (clone-indirect-buffer newname nil norecord)))
          (cond
           ((eq display 'switch) (switch-to-buffer newbuf))
           (display (pop-to-buffer newbuf)))
          ;; Otherwise -> do nothing
          newbuf))
    #+END_SRC

    Some interactive argument parsing logic from
    =clone-indirect-buffer= is duplicated [[(cloneBufferArgParse)][here]], but I see no great way
    to avoid doing this. We really /do/ need to check if the current
    major mode supports cloning before we do anything else.


    Lastly, lets add advice to =clone-indirect-buffer= and
    =clone-indirect-buffer-other-window= to setup the same hooks used
    in the function above.

    #+NAME: lit-emacs-clone-indirect-buffer-advice
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (defun my--before-clone-indirect-advice(&rest ignored)
        "Advice to run before `clone-indirect-buffer'.

      Will also affect `clone-indirect-buffer-other-window', since it
      calls `clone-indirect-buffer'.

      All arguments are IGNORED.

      Adds `my--living-clones-kill-buffer-query-fun' and
      `my--clean-up-indirect-buffer-clone-hooks-hook' to the
      `kill-buffer-query-functions' and `clone-indirect-buffer-hook'
      hook lists of the base buffer of the current buffer."
        (with-current-buffer (my--get-base-buffer)
          (add-hook 'kill-buffer-query-functions
                    #'my--living-clones-kill-buffer-query-fun
                    nil
                    t)
          (add-hook 'clone-indirect-buffer-hook
                    #'my--clean-up-indirect-buffer-clone-hooks-hook
                    nil
                    t)))
      ;; Add the advice.
      (advice-add 'clone-indirect-buffer
                  :before
                  #'my--before-clone-indirect-advice)
    #+END_SRC

    This renders [[(myCloneIndInstallHooks)][the corresponding block]] in =my-clone-indirect-buffer=
    redundant, but it's nice to have it there too, in case the advice
    needs to be switched off for whatever reason.

*** Destruction

    We need a convenient way to kill a group of clone
    buffers. The way to do that is to kill the original one. To
    facilitate that we define =my-kill-base-buffer=, which finds the
    base buffer of the given buffer and calls =kill-buffer= on it.

    #+HEADER: =my-kill-base-buffer=
    #+NAME: lit-emacs-my-kill-base-buffer
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (defun my-kill-base-buffer (&optional buffer-or-name)
        "Kill the base buffer of BUFFER-OR-NAME.

      If BUFFER-OR-NAME was omitted or is nil, the base buffer of the
      current buffer is targeted instead.  See `buffer-base-buffer' and
      `kill-buffer' for details on what this means.

      If called interactively with a prefix argument, prompt for a
      buffer to target using the minibuffer.

      Returns t if a buffer was killed, nil otherwise."
        (interactive
         (list
          (when current-prefix-arg
            (read-buffer "Name of buffer to target: " (current-buffer) t))))
        (kill-buffer (my--get-base-buffer buffer-or-name)))
    #+END_SRC

    Obviously, this is reduces to just =kill-buffer= when the argument
    is not an indirect buffer. For an indirect buffer though, this
    really will kill it, its base buffer, and its siblings.


    Sometimes it's useful to be able to kill off indirect clones but not the base buffer.

    #+HEADER: =my-kill-indirect-buffers-of=
    #+NAME: lit-emace-my-kill-indirect-buffers-of
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (defun my-kill-indirect-buffers-of (&optional buffer-or-name
                                                    switch-to-base
                                                    echo-kill-count)
        "Kill all indirect buffers with the same base buffer as BUFFER-OR-NAME.

      BUFFER-OR-NAME must be a buffer, a string or nil.

      If BUFFER-OR-NAME is nil, the current buffer is used instead.  If
      called with interactively with a prefix argument, prompt the user
      for a buffer to target instead of the current buffer.

      If BUFFER-OR-NAME is a string that is not the name of an existing
      buffer, do nothing and return nil.

      If SWITCH-TO-BASE is non-nil, switch to the base buffer of
      BUFFER-OR-NAME using `switch-to-buffer' before killing the
      indirect buffers.  This is always done when called interactively.

      If ECHO-KILL-COUNT is non-nil, show a message about the number of
      buffers killed.  This is always done when called interactively.

      The number of buffers killed is returned, or nil if
      BUFFER-OR-NAME does not exist."
        (interactive
         (list
          (when current-prefix-arg
            (read-buffer "Name of buffer to target: " (current-buffer) t))
          t
          t))
        (let* ((basebuf (my--get-base-buffer buffer-or-name))
               (targetlist (my-indirect-buffer-list-with-base-buffer-of basebuf))
               (numtargets (length targetlist)))
          (if (not basebuf) nil
            (when switch-to-base (switch-to-buffer basebuf nil t))
            (let ((numkilled (seq-reduce
                              #'(lambda(acc val)
                                  (if (kill-buffer val)
                                      (+ 1 acc)
                                    acc))
                              targetlist 0)))
              (when echo-kill-count
                (message "Killed %d indirect buffers (out of %d)"
                         numkilled
                         numtargets))
              numkilled))))
    #+END_SRC


*** Management

**** Switching

     In order to make switching between indirect buffers easier, we
     define a function specifically for that.

     #+NAME: lit-emacs-my-swithc-to-buffer-with-base-buffer-of
     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
       (defun my-switch-to-buffer-with-base-buffer-of (&optional buffer)
         "Prompt for a buffer sharing its base buffer with BUFFER and switch to it.

       If BUFFER is omitted or nil, use the current buffer instead.

       With a prefix argument, prompt for the base buffer to use.

       This function is intended exclusively for interactive use."
         (declare
          (interactive-only
           "Please use my-buffer-list-with-base-buffer-of directly instead"))
         (interactive
          (list (when current-prefix-arg
                  (read-buffer "Base buffer: " (current-buffer) t))))
         (let* ((buf (or (my--get-buffer buffer) (current-buffer)))
                (buflist
                 (my-buffer-list-with-base-buffer-of
                  buf
                  #'(lambda (b)  (not (eq b buf))))))
           ;; Error if the chosen buffer disappeared while we were selecting
           ;; it.
           (switch-to-buffer                                         ;(compReadBuffer)
            (my--get-buffer-or-err
            (completing-read "Switch to sibling buffer: "
                             (seq-map #'buffer-name buflist) nil t)))))
     #+END_SRC

     This is a somewhat primitive approach using completing read. But
     that plays nice with =helm= without having to make a new source.

     One thing to note here is line [[(compReadBuffer)]] where a string
     rather than a buffer is actually passed to
     =switch-to-buffer=. This irks me a little, but there's not much to
     be done. I could build an alist connecting buffers and buffer
     names, prompt for one of the keys and then fetch the actual buffer
     from alist. But that wouldn't do a whole lot here. There's no
     danger of the buffer not existing that wouldn't also be present if
     I went the alist route.

**** Making a view unique

     If I have the same buffer open in multiple windows in the same
     frame, I'd like to be able to make the currently selected one
     "unique". I mean by this, that I'd like to swap the current one
     for a preexisting indirect clone, or create one if one does not
     exist.

     #+NAME: lit-emacs-make-current-view-unique
     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
       (defun my-make-current-view-unique ()
         "Make the buffer in the current window unique in the `selected-frame'.

       For the purposes of this command, a buffer is unique in a frame
       if there is only one visible window displaying it.  To achieve
       its goal, this function will, if needed, try to find a not
       currently visible buffer with the same base buffer as the current
       buffer and switch to that one.  If multiple such buffers are
       found, the user is queried for which one to use.  If no such
       buffers exist, create a new one using
       `my-clone-indirect-buffer'.

       This function is intended for interactive use only.  If you want
       something like this for non-interactive use, you're going to have
       to call `my-buffer-list-with-base-buffer-of' and
       `my-clone-indirect-buffer' yourself."
         (declare
          (interactive-only
           (concat
            "Please use my-clone-indirect-buffer and "
            "my-buffer-list-with-base-buffer-of directly instead")))
         (interactive)
         (let* ((this-frame (selected-frame))
                (this-buf   (my--get-buffer))
                (windows-with-buf
                 (get-buffer-window-list this-buf nil this-frame)))
           (if (< 1 (length windows-with-buf))
             (let ((candidates
                    (my-buffer-list-with-base-buffer-of
                     this-buf
                     #'(lambda (b)
                         (and (not (eq this-buf b))
                              (= 0 (length
                                    (get-buffer-window-list b nil this-frame))))))))
               (cond
                ((null candidates)
                 (message "Cloning buffer %s.." (buffer-name this-buf))
                 (my-clone-indirect-buffer nil 'switch t))
                ((= 1 (length candidates))
                 (message "Switching to sole candidate %s.."
                          (buffer-name (car candidates)))
                 (switch-to-buffer (car candidates) t t))
                (t
                 (let ((candidate
                        ;; Raise error if the candidate buffer disappeared
                        ;; while we were selecting it.
                        (my--get-buffer-or-err
                         (completing-read
                          "Select a non-visible sibling buffer: "
                          (seq-map #'buffer-name candidates) nil t))))
                   (message "Switching to selected candidate %s.." candidate)
                   (switch-to-buffer candidate t t)))))
             (message
              "Buffer %s is already unique in frame.." (buffer-name this-buf)))))
     #+END_SRC

*** Keybindings: Indirect Buffers               :actual_keybind_loc:noexport:

    #+BEGIN_SRC emacs-lisp
    <<lit-emacs-indirect-buffer-key-binds>>
    #+END_SRC

** Emacs Server

   Should be booted up if it isn't already. Unless we're in
   =noninteractive= mode.

   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     ;; Start the server after init, unless we're in batch mode or
     ;; something.
     (use-package server
       :unless  noninteractive
       :no-require t
       :hook (after-init . server-start))
   #+END_SRC

** =pdf-tools=

   Not exactly basic, but I'd like to get this out of the way early,
   and I'm not sure where else to put it.

   Note that when this package is updated, the pdf-tools backends
   will need to be rebuilt. This rebuilding process will cause a
   prompt to appear in emacs, which means it may be unwise to start
   emacs as a daemon immediately after updating that package. Since
   you might not see the prompt.

   #+NAME: lit-emacs-init-pdf-tools
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     (use-package pdf-occur
       :defer t
       :ensure pdf-tools
       :after pdf-tools
       :commands (pdf-occur-global-minor-mode))
     (use-package pdf-tools
       :defer t
       :ensure t
       ;; Trick copied from the use-package README. This will load
       ;; pdf-tools just in time.
       :commands (pdf-tools-install)
       :magic ("%PDF" . pdf-view-mode)
       :config (pdf-tools-install))
   #+END_SRC

** Misc Look And Feel

*** =powerline= and =encourage=

    A pair of straight forward ui packages.

    #+NAME: lit-emacs-init-powerline-setup
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      ;; These don't do anything in non-interactive mode.
      (use-package powerline
        :defer t
        :ensure t
        :functions (my-powerline-vc)
        :config
      <<my-powerline-vc-advice>>
        :hook (after-init . powerline-default-theme))
      ;; No real point in deferring this; it's tiny.
      (use-package encourage-mode
        :ensure t
        :diminish)
    #+END_SRC

    WRITTEN [2019-05-19 sön]:

    =powerline= by default checks whether ~(buffer-file-name
    (current-buffer))~ is ~nil~, as part of the logic to determine
    whether to show vcs information. This doesn't work particularly
    well in indirect buffers, where that value is always nil. Thus,
    I'm forced to override it with my modified version defined here.

    #+NAME: lit-init-my-powerline-vc-advice
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :tangle no :noweb-ref my-powerline-vc-advice
      ;; Identical to powerline-vc save for using `my--get-base-buffer'
      ;; instead of `current-buffer'.
      (defpowerline my-powerline-vc
        (when (and (buffer-file-name (my--get-base-buffer)) vc-mode)
          (if (and window-system (not powerline-gui-use-vcs-glyph))
              (format-mode-line '(vc-mode vc-mode))
            (format " %s%s"
                    (char-to-string #xe0a0)
                    (format-mode-line '(vc-mode vc-mode))))))
      (init-say "Overriding the definition of powerline-vc.." "powerline")
      (advice-add 'powerline-vc :override #'my-powerline-vc)
    #+END_SRC


*** The =delight= package

    A fancier version of =dimninish=, pretty much.

    #+NAME: lit-init-general-delight
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (use-package delight
        :ensure t)
    #+END_SRC
*** Additional =delight= / =dimninish= invocations

    Some =diminish= calls that need to happen, but which don't really
    belong anywhere.

    #+NAME: lit-init-general-additional-diminish
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (diminish 'eldoc-mode)
    #+END_SRC


** Other misc packages

   Packages I need here for some reason or another, but which don't
   obviously belong in any particular category.

   - =htmlize=

     Required by =org= export functions, to export highlighted code
     blocks to html properly.

     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
       (use-package htmlize
         :defer t
         :ensure t)
     #+END_SRC


* Project Management

  Version control, project navigation, etc.

** =magit=

   The cleanest git interface I've yet to encounter.

   #+NAME: lit-emacs-init-magit-setup
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     (use-package magit
       :bind ("H-g" . magit-status)
       :ensure t
       :config
       (use-package magit-files
         :commands (global-magit-file-mode)
         :ensure magit
         :config
         (global-magit-file-mode)))
   #+END_SRC

** =projectile=

   The project management package.

   #+NAME: lit-emacs-init-projectile-setup
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     (use-package projectile
       :defer 5 ;; Load unconditionally after 5 seconds
       ;; Reduce mode line impact
       :delight '(:eval (concat " [" (projectile-project-name) "]"))
       :ensure t
       :commands (projectile-mode)
       :config (projectile-mode +1)
       :bind-keymap ("H-p" . projectile-command-map))               ;(projectileKeymap)
   #+END_SRC

   I'm defining how to access the ~projectile-mode-map~ [[(projectileKeymap)][here]] rather
   than any specific command, as that's the recommended way to set
   this up.




* Editing Functionality

  Packages related to code or text editing.

** General Editing Functionality



*** =company=

    Completion setup is fairly simplistic:

    #+NAME: lit-emacs-init-company-setup
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (use-package company
        :defer 2 ;; Load unconditionally after 2 sec
        :diminish company-mode
        :ensure t
        :commands
        (company-abort
         company-complete-number
         global-company-mode)
        :bind (:map global-map
                    ("C-:" . company-complete))                ;(companyCompleteBind)
        :config
        ;; Taken from jweigley's dot-emacs repo.                        ;(jwRepoNote)

        ;; See http://oremacs.com/2017/12/27/company-numbers/
        (defun ora-company-number ()
          "Forward to `company-complete-number'.
        Unless the number is potentially part of the candidate.
        In that case, insert the number."
          (interactive)
          (let* ((k (this-command-keys))
                 (re (concat "^" company-prefix k)))
            (if (cl-find-if (lambda (s) (string-match re s))
                            company-candidates)
                (self-insert-command 1)
              (company-complete-number (string-to-number k)))))

        (let ((map company-active-map))
          (mapc
           (lambda (x)
             (define-key map (format "%d" x) 'ora-company-number))
           (number-sequence 0 9))
          (define-key map " " (lambda ()
                                (interactive)
                                (company-abort)
                                (self-insert-command 1))))
        (global-company-mode 1))
    #+END_SRC

    Some notes:

    - [[(companyCompleteBind)][This]] is not the only place where I make bindings
      related to the ~company-mode-map~.

    - All of the [[(jwRepoNote)][config code]] above was taken from John Weigley's
      [[https://github.com/jwiegley/dot-emacs][dot-emacs]] repository. From his =init.el= file specifically.

    - Which modes are affected by the =global-company-mode= is
      determined by a =custom= variable.


**** Additional =company= backends

     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
       (use-package company-cabal
         :after (company)
         :ensure t
         :defer t)
       (use-package company-ghci
         :after (company)
         :ensure t
         :defer t)
       (use-package company-c-headers
         :after (company)
         :ensure t
         :defer t)
       (use-package company-glsl
         :after (company)
         :ensure t
         :defer t)
       (use-package company-math
         :after (company)
         :ensure t
         :defer t)
       (use-package company-quickhelp
         :after (company)
         :ensure t
         :defer t)
     #+END_SRC

*** =pcomplete=

    Set up =pcomplete= as a =completion-at-point= function. =org=
    wants this, plus it gives me a neat way to add basic custom
    completion for certain basic things like =haskell= pragmas and the
    like. In general =pcomplete= can be useful to set up when the set
    of possible things to complete is small and the set of completions
    is small. It's sort of like the completion framework in
    =bash=. Dumb, but straight-forward.

    Note: This is very much /not/ a replacement for "real" completion
    facilities. I think more of it as being a useful way to add basic
    custom completion. Not totally unlike =abbrev=, but slightly
    cleverer.

    #+NAME: lit-emacs-init-pcomplete-setup
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"

      (use-package pcomplete
        :defer t
        :no-require t ; built in, I believe
        :commands (pcomplete
                   pcomplete-completions-at-point
                   pcomplete--here
                   pcomplete-entries)
        :bind (:map global-map
                    ("H-! c <tab>" . pcomplete))
        ;; Tying the load to company-mode for now.
        :init
        (defun my-setup-pcomplete-capf-hook()
          (add-hook 'completion-at-point-functions #'pcomplete-completions-at-point))
        :config
        (unless (or (get 'pcomplete-default-completion-function 'saved-value)
                    (get 'pcomplete-default-completion-function 'themed-value))
          (mapc (apply-partially #'message "[init-general|pcomplete] %s")
                '(
      "pcomplete-default-completion-function appears to be set to it's default value!"
      "This is not advisable, as it won't compile and evaluate properly."
      "Attempting to set alternate value.."))
          (customize-set-variable
           'pcomplete-default-completion-function
           #'(lambda() (pcomplete-here (pcomplete-entries)))    ;(pcmp:defaultCmpDef)
           (concat "[init-general] Auto-replaced, to avoid "
                   "errors if `pcomplete.el' was loaded in "
                   "compiled form. Equivalent to the "
                   "original definition given in "
                   "`pcomplete.el'.")))
        (unless (or (get 'pcomplete-command-completion-function 'saved-value)
                    (get 'pcomplete-command-completion-function 'themed-value))
          (mapc (apply-partially #'message "[init-general|pcomplete] %s")
                '(
      "pcomplete-command-completion-function appears to be set to it's default value!"
      "This is not advisable, as it won't compile and evaluate properly."
      "Attempting to set alternate value.."))
          (customize-set-variable
           'pcomplete-command-completion-function
           #'(lambda () (pcomplete-here (pcomplete-executables)))
           (concat "[init-general] Auto-replaced, to avoid "
                   "errors if `pcomplete.el' was loaded in "
                   "compiled form. Equivalent to the "
                   "original definition given in "
                   "`pcomplete.el'.")))
        :hook (company-mode . my-setup-pcomplete-capf-hook))

    #+END_SRC



    *IMPORTANT NOTE*: Do /not/ use the default value for
    =pcomplete-default-completion-functions=, as it will misbehave and
    throw "invalid function" errors both when invoked using
    =pcomplete= and when used as a completion at point back-end for
    =company=. The [[(pcmp:defaultCmpDef)][lambda expression]] I substitute it with is precisely
    the same as the definition given in =pcomplete.el= except quoted
    in a slightly different way[fn:pcomp], which makes the
    byte-compiler do the right thing.

    If anyone reading this actually cares about the details of what
    this is fixing: the default value that =customize= ends up with if
    =pcomplete.el= is byte-compiled is the same lambda expression I've
    used in the code above, but with /only the lambda part
    byte-compiled!/ Meaning the =pcomplete-here= macro doesn't get
    compiled out of existence, which then leads to "invalid function
    pcomplete-here" errors when you try to invoke completion using
    =pcomplete=. If the expression is quoted as ='(lambda () ...)=,
    the byte compiler won't touch it which allows =emacs= to recognise
    that the expression inside the lambda is a macro and /not/ a
    function. Alternatively, if the expression is quoted as =#'(lambda
    () ...)=, the byte-compiler will instead compile both it /and/ its
    body, thus annihilating the macro completely and leaving us with a
    byte-compiled lambda wrapping some function calls. Either approach
    will solve the issue.

[fn:pcomp] or arguably the same way, but at a different time / in a
    different context. The order of operations and evaluation
    semantics involved in quoting/anti-quoting/macro-expansion/etc
    during compilation and their consequences for the meaning of an
    expression at run-time are subtle and treacherous.

*** =avy= editing/navigation

    #+NAME: lit-emacs-init-avy-prog-mode-setup
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      ;; Fast navigation and 'zap'-ing to specific nearby chars, with a
      ;; keyboard based "disambiguation" mode.
      (use-package avy                                                     ;(avyMode)
        :defer t
        :ensure t
        :commands (avy-setup-default)
        :config (avy-setup-default)
        :bind (("C-'" . avy-goto-char-2)
               ("C-*" . avy-goto-subword-1)
               ("H-'" . avy-goto-char-in-line)))
      (use-package avy-zap
        :defer t
        :ensure t
        :bind (("M-z" . avy-zap-up-to-char)
               ("M-Z" . avy-zap-to-char)))
    #+END_SRC


    For info on what [[(avyMode)][=avy=]] does exactly, see the built-in
    documentation or https://github.com/abo-abo/avy.



*** =flyspell= and =flycheck=

    #+NAME: lit-emacs-init-flyspell-flycheck-setup
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      ;; flyspell
      (use-package flyspell
        :diminish flyspell-prog-mode                            ;(flyspellProgMode)
        :diminish flyspell-mode
        :ensure t
        :config
        ;; Delete some default bindings, to stop flyspell from eating up
        ;; keyboard real-estate that other modes (like org) could make much
        ;; better use of.  This needs to happen during config, since if I
        ;; modify the map before it's loaded, the modification won't stick.
        (unbind-key "C-c $" flyspell-mode-map)
        (unbind-key "C-M-i" flyspell-mode-map)
        ;; helm-flyspell overwrites this one anyway.
        (unbind-key "C-;" flyspell-mode-map)
        :hook ((prog-mode . flyspell-prog-mode)
               (text-mode . flyspell-mode)))

      ;; flycheck
      (use-package flycheck
        :ensure t
        :hook ((prog-mode     . flycheck-mode)))
               ;(flycheck-mode . flycheck-cask-setup)))

      ;; pos-tip support for displaying flycheck errors
      (use-package pos-tip
        :ensure t
        :defer t)
      (use-package flycheck-pos-tip
        :diminish
        :ensure t
        :after (flycheck)
        :hook (flycheck-mode . flycheck-pos-tip-mode))

    #+END_SRC

    Note that ~flyspell-mode~ for /programming/ mode is a [[(flyspellProgMode)][different]]
    mode than the /text/ oriented one.





** Code Editing Functionality

   Firstly some general stuff:

   #+NAME: lit-emacs-init-delims-wc-etc-prog-mode-setup
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     (use-package rainbow-delimiters
       :ensure t
       :hook (prog-mode . rainbow-delimiters-mode)
       :diminish)

     (use-package smartparens
       :ensure t
       :hook (prog-mode . smartparens-mode)
       :diminish)

     (use-package column-enforce-mode
       :ensure t
       :hook (prog-mode markdown-mode)
       :diminish)

     (use-package highlight-indentation
       :ensure t
       :hook ((prog-mode . highlight-indentation-mode)
              (prog-mode . highlight-indentation-current-column-mode)
              (org-mode  . highlight-indentation-mode))
       :diminish highlight-indentation-mode
       :diminish highlight-indentation-current-column-mode)

     (use-package whitespace-cleanup-mode
       :ensure t
       :hook (prog-mode org-mode)
       :diminish)
   #+END_SRC

   Delimiter and whitespace handling. Not all that exiting. And
   column-enforce also applies to =text-mode=.

*** Lang Major Modes

    Initialisation for specific programming language major modes. Many
    don't need anything specific, but a handful do.

    - Haskell

      Due to a key map conflict with ~haskell-interactive-mode~, I
      need to unset some bindings when ~haskell-mode~ loads.

      #+NAME: lit-emacs-init-haskell-mode
      #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
        (use-package haskell-mode
          :ensure t
          :defer t
          :config
          (mapc (lambda (x) (define-key haskell-mode-map (kbd x) nil))
                '("C-c C-i"
                  "C-c C-l"
                  "C-c C-t"
                  "C-c C-b"
                  "C-c C-v")))

        (use-package hlint-refactor
          :ensure t
          :defer t)

        (use-package flycheck-haskell
          :after (flycheck haskell-mode)
          :ensure t
          :hook (haskell-mode . flycheck-haskell-setup))

      #+END_SRC

    - Idris

      #+NAME: lit-emacs-init-idris-mode
      #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
        (use-package idris-mode
          :ensure t
          :defer t)

        (use-package helm-idris
          :ensure t
          :defer t
          :after (helm idris-mode))
      #+END_SRC

    - MATLAB

      Important note: The /package/ is called ~matlab-mode~, but the
      /library and feature/ is called ~matlab~. Thus one must load the
      the ~matlab~ library, but /ensure/ the ~matlab-mode~
      package. Confusing, but that's life.

      #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
        (use-package matlab
          :ensure matlab-mode
          :defer t)
      #+END_SRC

** Text Editing Functionality

   Not much text specific going on in this file. Just =pandoc=,
   basically.

   #+NAME: lit-emacs-init-pandoc-mode-setup
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     (use-package markdown-mode
       :ensure t
       :config (use-package pandoc-mode
                 :ensure t
                 :diminish
                 :commands pandoc-load-default-settings
                 :hook markdown-mode
                 :config (pandoc-load-default-settings)))
   #+END_SRC
