#+TITLE: Main Emacs Initialisation File
#+Author: Nils Gustafsson
#+OPTIONS: num:3 toc:nil
#+TAGS: { export(e) noexport(n) } { out_of_seq_keybind(O) actual_keybind_loc(A) }
#+PROPERTY: header-args :noweb no-export :tangle yes :exports code :comments link :padline true

General/misc package setup. In other words, this is where I configure
and load packages that don't fit in any other obvious
category. Imported by [[file:~/.emacs.d/init.el][init.el]].


* Imports and Prerequisites

  - I want lexical scoping here.

    #+NAME: lit-emacs-general-header
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :comments no
    ;;; lit-emacs-init-general.el -*- lexical-binding: t -*-
    ;;; Commentary:
    ;;;
    ;;; Generated from lit-emacs-init-general.org
    #+END_SRC

  - This file needs access to the full =use-package= package when
    compiled.

    #+NAME: lit-emacs-general-imports
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (eval-when-compile
        (require 'use-package))
    #+END_SRC

* Basic Emacs Initialisation

  Some basic things I need out of the way.

** A note for readers

   Some sections, such as [[*Indirect Buffers]], start with a list of key
   bindings for functions which are really defined in various
   locations throughout that section as a whole. These key bindings
   are displayed first, because they provide a nice quick overview of
   the main commands to be defined in the given section.

   The /actual/ site at which such a block is typically going to end
   up when source code is extracted from the original =org= file, is
   at the very end of the same section of the file. Sections with out
   of sequence key binding blocks in them are tagged with
   ~out_of_seq_keybind~ tags. The sections where these bindings
   /actually/ are not included when documentation is exported from
   this =org= file, but are tagged with ~actual_keybind_loc~ (and also
   ~noexport~) in the =org= source.



** Basic Window and Buffer Keys

   Firstly, some window-related stuff. I need a function to split the
   frame into three side-by-side windows, because that's my preferred
   default layout.

   #+NAME: lit-emacs-my-split-to-3-windows
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     (defun my-split-to-3-windows ()                                 ;(defNilguSplitwin)
       "Splits the current window until this frame has 3 and then balances them."
       (interactive)
       (let ((num (- 3 (count-windows))))
         (when (> num 0)
           (dotimes (_i num) (split-window-right nil))
           (balance-windows))))
   #+END_SRC

   And here are my global keys for window/buffer movment:

   #+NAME: lit-emacs-init-window-keybinds
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     ;; Window/buffer manipulation
     (use-package buffer-move
       :defer t
       :bind (:map global-map
                   ("C-H-<left>"  . buf-move-left)
                   ("C-H-<right>" . buf-move-right)
                   ("C-H-<up>"    . buf-move-up)
                   ("C-H-<down>"  . buf-move-down)))
     (bind-keys
      :map global-map
      ("H-<left>"  . windmove-left)
      ("H-<right>" . windmove-right)
      ("H-<up>"    . windmove-up)
      ("H-<down>"  . windmove-down)
      ("C-x C-M-s" . my-split-to-3-windows)                         ;(splitwinBind)

      ;; Save, exit, and kill the server
      ("C-x C-M-c" . save-buffers-kill-emacs)                  ;(savebuffkillemacs)

      ;; Delete the current frame.
      ("H-q" . delete-frame)

      ;; Better keybinding for dabbrev-expand, as "M-\" is awkward on a
      ;; nordic keyboard.
      ("H-:"       . dabbrev-expand)

      ;; Useful command for basic code formatting. Especially for
      ;; struct/record layouts, list/map literals and the like.
      ("C-c a"     . align-regexp)                               ;(alignregexpBind)

      ;; Narrowing keys. See also my org settings.
      ("H-n n"     . narrow-to-region)
      ("H-n f"     . narrow-to-defun)
      ("H-n P"     . narrow-to-page)
      ;; Undo the narrowing.
      ("H-n w"     . widen))

   #+END_SRC

   Two noteworthy lines above are line [[(splitwinBind)]], in which I make
   use of [[(defNilguSplitwin)][my-split-to-3-windows]], and line [[(savebuffkillemacs)]] which sets up a
   binding for killing the current client /and/ the server.

   Additionally, there's a binding for [[(alignregexpBind)][align-regexp]], which is a handy
   tool to have for quick ad-hoc code formatting. Can be combined with
   a prefix argument. for a more powerful version of the command.

   A further note: the "H" in the keybindings above refers to the
   "Hyper" key, which is what I've reassigned capslock to. Because who
   even uses capslock?


** Narrowing and Pages

   The narrowing and page ideas in =emacs= are neat, but inserting
   form feed characters in to source code willy nilly makes me a
   little uncomfortable.

   So, based on the ideas in page.el, I'll implement my own substitutes.

*** =my-page-sep=: Definition

    First, let's define what my page separators even are:

    #+NAME: lit-emacs-init-page-sep-def
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (defvar my-page-sep-special-prefix nil
        "Special prefix to be used instead of `comment-start' in `my-page-sep'.

      Default value is nil, meaning no special prefix. This is the
      right choice in most modes.

      When this is non-nil it should be a string CONTAINING NO
      LINEBREAKS, and will replace the `comment-start' as the starting
      token for a `my-page-sep'. Setting it to a non-nil value also
      causes the end token of `my-page-sep' to be omitted entirely.")

      (eval-when-compile

        (defsubst my--page-sep-trim-start(s)
          (string-trim-left
           (if (< 0 (- (length s)
                       (length (string-trim-right s))))
               s
             (concat s " "))))

        ;; For §- (section separator)
        (defsubst my--page-sep-start-tok()
          (cond
           ;; Use the special prefix if it exists
           (my-page-sep-special-prefix
            (my--page-sep-trim-start my-page-sep-special-prefix))
           ;; If not, use comment-start
           (comment-start
            (my--page-sep-trim-start comment-start))
           ;; Use the empty string if it does not
            (t "")))


        (defsubst my--page-sep-end-tok()
          ;; 1. If my-page-sep-special-prefix is non-nil, ignore this token
          ;; completely.
          ;;
          ;; 2. I check for comment-start rather than comment-end here
          ;; because I don't know how I'd even begin to interpret what it
          ;; would mean for comment-end to be well defined when
          ;; comment-start is not.
          (if (and (not my-page-sep-special-prefix)
                   comment-start)
              (string-trim-right
               ;; Don't use comment-end if it's the empty string
               (if (and comment-end (not (string= comment-end "")))
                   (if (< 0 (- (length comment-end)
                               (length (string-trim-left comment-end))))
                       comment-end
                     (concat " " comment-end))
                 ;; If comment-end is nil or "" use a backwards start-tok
                 (reverse (my--page-sep-start-tok))))
            ;; Return an empty string if comment-start was nil
            ""))

        (defconst my--page-sep-center-tok
                "§ ────────── ────────── ────────── ────────── ──────────"))

      (defmacro my-page-sep-length()
        "Compute the length of the output of `my-page-sep'."
        `(+ (length (my--page-sep-start-tok))
            ,(length my--page-sep-center-tok)
            (length (my--page-sep-end-tok))))

      (defmacro my-page-sep()
        "My page separator token.

      See `insert-my-page-sep', `my-at-page-sep-p', `my-forward-page',
      `my-backward-page', and `my-narrow-to-page'."
        `(concat
          (my--page-sep-start-tok)
          ,my--page-sep-center-tok
          (my--page-sep-end-tok)))

    #+END_SRC

    The above snippet defines the separator and it's length as a pair
    of macros, since the exact value is going to depend on the local
    comment syntax.

    Next, I need some simple functions to insert and detect these:

    #+NAME: lit-emacs-init-page-sep-defuns
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      ;; TODO: allow trailing whitespace?
      (defun my-at-page-sep-p()
        "Return t if the current line contains a valid page separator.

      A valid page separator consists of a `comment-start' followed by
      a space (if needed), and the string \"§ ────────── ────────── ────────── ────────── ──────────\",
       followed by a space (if needed) and a `comment-end`, or, if
      `comment-end' is nil/empty, a reversed `comment-start'.

      If this explanation seems unclear, try invoking
      `my-insert-page-sep' to see an actual example."
        (save-excursion
          (beginning-of-line)
          (let ((sep (my-page-sep))
                (here (point))
                (there (progn (end-of-line) (point))))
            ;; Evaluates to nil if there is beyond the end of the buffer, or
            ;; the buffer-substring from here to there isn't the separator.
            (and (> (point-max) there)
                 (string= sep
                          (buffer-substring here
                                            there))))))
      (defun my-insert-page-sep()
        "Insert a page separator at the beginning of the current line.

      Any preexisting content on the line, including the cursor, is
      moved to the next line but is otherwise unchanged."
        (interactive)
        ;; Remember where we were, so we can move the point back to the same
        ;; column
        (let ((col (current-column)))
          (beginning-of-line)
          (insert (my-page-sep))
          (newline)
          (move-to-column col)))

      (defun my-count-lines-page()
        "Similar to `count-lines-page', but using `my-page-sep'.

      Displays the total number number of lines from the start of the
      current page up to the end of the current page. In parenthesis
      are:

      A. the number of lines from the start of the current page up to,
      but not including, the current line.
      B. the number one (representing the current line).
      C. the number of lines from the line following the current one to
      the end of the page.

      In other words the lines before point and lines after point will
      sum to 1 less than the number of lines in the page. So if the
      point is on the 4th line of a 5 line page, the output should look
      like this:

       \"Page has 5 (3 + 1 + 1) lines\".

      If the point is on a page separator, \"At page separator\" will
      be displayed instead.

      See `my-at-page-sep-p' for a simple description of what the
      separator looks like."
        (interactive)
        (if (my-at-page-sep-p)
            (message "At page separator")
          (save-excursion
            (let ((here (line-number-at-pos))                        ;(psepCountLines)
                  (bot (progn
                         (my-forward-page)
                         (when (my-at-page-sep-p)
                           (backward-char))
                         (line-number-at-pos)))
                  (top (progn
                         (my-backward-page)
                         (when (my-at-page-sep-p) (forward-line))
                         (line-number-at-pos) )))
              (message "Page has %d (%d + 1 + %d) lines"
                       (+ (- bot top) 1)
                       (- here top)
                       (- bot here))))))

      (bind-keys :map global-map
                 ("H-- -" . my-insert-page-sep)
                 ("H-- l" . my-count-lines-page))

    #+END_SRC

    I've elected to bind this to an available global binding, because
    I'll probably want to use it a lot.

    One thing worth noting in the above block is the use of
    =backward-char= and =forward-line= in the [[(psepCountLines)][let binding]] in
    =my-count-lines-page=, which is meant to exclude the page
    separators themselves. The exact same logic is going to show up in
    =my-narrow-to-page= in the next section, except there we also
    employ =forward-line= to exclude the starting page separator as
    well. Note also, that 1 is added to the "line total",

*** =my-page-sep=: Navigation and Narrowing

    So.. how /does/ one make use of these? By using them as anchors
    for navigation, and narrowing.

    In order to do that though, I need to define two basic primitives:
    #+NAME: lit-emacs-init-page-sep-nav-and-narrow-prim
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (eval-when-compile
        (defsubst my--to-next-page-sep-forward()
          (end-of-line)                                             ;(psepForwardEOL)
          (search-forward (my-page-sep) nil 'move)
          (while (not (or (eobp)
                          (my-at-page-sep-p)))
            (search-forward (my-page-sep) nil 'move))
          (beginning-of-line)                                       ;(psepForwardBOL)
          (point))

        (defsubst my--to-next-page-sep-backward()
          (search-backward (my-page-sep) nil 'move)
          (while (not (or (bobp)
                          (my-at-page-sep-p)))
            (search-backward (my-page-sep) nil 'move))
          (point)))
    #+END_SRC

    Note the use of [[(psepForwardEOL)][=end-of-line=]] and [[(psepForwardBOL)][=beginning-of-line=]]
    here. They're needed because =search-forward= with a non-nil-non-t
    3rd argument places the point /at the end of the match/, which is
    not where I want to be. To be specific, the =end-of-line= bit is
    there to compensate for the =beginning-of-line= bit which would
    cause a "movement loop" with =search-forward= if we're already at
    a page separator. The net result is a little bit of wasted
    movement work, but I don't think that matters much for a function
    that's almost exclusively going to be invoked by user input. The
    user won't notice the delay.

    =search-backward= already puts the point at the beginning of the
    match, so the corresponding shenanigans aren't necessary there.


    I can now define the actual user-facing "page forward" and "page
    backward" functions. I'm following the standard nomenclature used
    in =page.el= here: "forward-page" and "backward-page".

    #+NAME: lit-emacs-init-page-sep-nav
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"

      ;; mimics the forward-page function
      (defun my-forward-page(&optional count)
        "Move to the beginning of the first `my-page-sep' after point.
      If no page separator is found after point, move to the end of the
      buffer instead.

      With optional argument COUNT: repeat COUNT times. A negative
      COUNT is taken to mean \"move to the beginning of the previous\"
      `my-page-sep' instead.

      With a COUNT of 0, nothing is done.

      If called interactively, COUNT may be specified as a numeric prefix."
        (interactive "p")
        (setq count (or count 1))
        (if (< count 0)
            (while (and (< count 0) (not (bobp)))
              (setq count (1+ count))
              (my--to-next-page-sep-backward))
          (while (and (> count 0) (not (eobp)))
            (setq count (1- count))
            (my--to-next-page-sep-forward))))

      ;; mimics the backward-page function
      (defun my-backward-page(&optional count)
        "Move to the beginning of the first `my-page-sep' before point.
      If no page separator is found before point, move to the beginning
      of the buffer instead.

      This function is exactly identical to `my-forward-page' with a
      negative argument."
        (interactive "p")
        (setq count (or count 1))
        (my-forward-page (- count)))                                    ;(myBackPage)

    #+END_SRC

    Nothing all that noteworthy about these definitions, aside from
    =my-backward-page= being pretty much just an [[(myBackPage)][alias for
    =my-forward-page=]] with a negative argument.

    Having done that, we define a narrowing function using my page
    separators.

    #+NAME: lit-emacs-init-page-sep-narrow
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"

      ;; Narrowing!
      (defun my-narrow-to-page()
        "Like `narrow-to-page', but using `my-page-sep'.

      See `my-at-page-sep-p' for a simple description of what the
      separators look like.

      Briefly: This function finds the next page separator after point,
      then the first page separator preceding that one, and invokes
      `narrow-to-region' to narrow the buffer to everything between
      those two separators apart from the separators themselves."
        (interactive)
        (save-excursion
          (my-forward-page)
          (when (not (eobp))
            ;; go back one char, to reach the end of the previous line
            (backward-char))
          (narrow-to-region
           (point)
           (progn
             (my-backward-page)
             (when (not (bobp))
               ;; go to the next line (we're already at the left margin)
               (forward-line))
             (point)))))

    #+END_SRC


    And versions of =my-forward-page= and =my-backward-page= that
    widen and then narrow to the arrived at page.

    #+NAME: liet-emacs-init-page-sep-narrow-nav
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (defun my-forward-narrow-page (&optional count)
        "Like `my-forward-page', except it narrows to the target page.

      Additionally it will widen the current buffer before
      moving, COUNT is treated the same way as it is in
      `my-forward-page'."
        (interactive "p")
        (widen)
        (setq count (or count 1))
        (my-forward-page count)
        (my-narrow-to-page))

      (defun my-backward-narrow-page (&optional count)
        "Like `my-backward-page' except it narrows to the target page.

      Additionally it will widen the current buffer before
      moving, COUNT is treated the same way as it is in
      `my-backward-page'."
        (interactive "p")
        (widen)
        (setq count (or count 1))
        ;; An extra + 1 is needed here, for us to narrow to the correct
        ;; page.
        (my-backward-page (+ 1 count))                             ;(backwardsOffset)
        (my-narrow-to-page))
    #+END_SRC

    A note regarding [[(backwardsOffset)]]: =my-backward-page= moves to
    the beginning of the /current/ page, or if we're already there the
    beginning of the page before that. But moving to the beginning of
    the current page and re-narrowing would be unhelpful. Thus we move
    an extra page backwards, so that it really always tries to narrow
    to the page /before/ the current one.


    Lastly, let's bind these things to some keys.

    #+NAME: lit-emacs-init-page-sep-bind-keys
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      ;; Bind some keys
      (bind-keys :map global-map
                 ;; next/prior is page up / page down
                 ("H-<next>" . my-forward-page)
                 ("H-<prior>" . my-backward-page)
                 ("C-H-<next>" . my-forward-narrow-page)
                 ("C-H-<prior>" . my-backward-narrow-page)
                 ;; Mirrors the binding for narrow-to-page.
                 ("H-n p" . my-narrow-to-page)
                 ;; Is consistent with "H-- -" and "H-- l" defined earlier.
                 ("H-- n" . my-narrow-to-page))
    #+END_SRC


** Indirect Buffers                                      :out_of_seq_keybind:

   Another interesting bit of functionality in =emacs= is the notion
   of an indirect buffer. In this section I define some nice helpers
   and a few hooks to make indirect buffers a little easier to make
   and use.


   #+HEADER: Commands defined in this section
   #+NAME: lit-emacs-indirect-buffer-key-binds
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :tangle no
     (bind-keys
      :map global-map

      ;; Clone the current buffer and switch to the clone.
      ("H-b c" . my-clone-indirect-buffer-here)

      ;; Kill the base buffer of the current buffer.
      ("H-b k" . my-kill-base-buffer))
   #+END_SRC

*** Primitives

    Let's start off with some low level primitives.

    #+NAME: lit-emacs-indirect-buffer-compile-primitives
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (eval-when-compile
        (defsubst my--get-base-buffer-of-buffer (&optional buffer)
      <<my--get-base-buffer-of-buffer-doc-string>>
          (or (buffer-base-buffer
               (or buffer
                   (current-buffer)))
              buffer))

        (defsubst my--get-buffer (&optional buffer-or-name)
      <<my--get-buffer-doc-string>>
          (or (get-buffer
               (or buffer-or-name
                   (current-buffer)))
              (error "No such buffer: %s" buffer-or-name)))

        (defsubst my--get-base-buffer (&optional buffer-or-name)
      <<my--get-base-buffer-doc-string>>
          (my--get-base-buffer-of-buffer
           (my--get-buffer buffer-or-name))))
    #+END_SRC

    #+NAME: my--get-base-buffer-of-buffer-doc-string
    #+BEGIN_SRC emacs-lisp :tangle yes :exports none
              "Returns the base buffer of BUFFER.

      If BUFFER is not an indirect buffer, return BUFFER.

      If BUFFER is omitted or nil, return the base buffer of the
      current buffer.

      The return value from this function is always a buffer object."
    #+END_SRC

    #+NAME: my--get-buffer-doc-string
    #+BEGIN_SRC emacs-lisp :tangle yes :exports none
              "Return the buffer named BUFFER-OR-NAME.

      BUFFER-OR-NAME must be a string or a buffer.

      If BUFFER-OR-NAME is a string and there is no buffer named
      BUFFER-OR-NAME, raise an error.

      If BUFFER-OR-NAME is a buffer, return BUFFER-OR-NAME.

      If BUFFER-OR-NAME is omitted or nil, return the current buffer.

      The return value from this function is always a buffer object, if
      it returns normally."
    #+END_SRC

    #+NAME: my--get-base-buffer-doc-string
    #+BEGIN_SRC emacs-lisp :tangle yes :exports none
          "Return the base buffer of BUFFER-OR-NAME.

      If BUFFER-OR-NAME is not an indirect buffer, return the buffer
      corresponding to BUFFER-OR-NAME.

      If BUFFER-OR-NAME is a string and there is no buffer named
      BUFFER-OR-NAME, raise an error.

      If BUFFER-OR-NAME is omitted or nil, return the base buffer of
      the current buffer.

      The return value from this function is always a buffer object, if
      it returns normally."
    #+END_SRC

    All three of the functions above are in scope only during
    compilation, making them useless outside of this file. They're
    really only here to make other definitions a little easier on the
    eyes. The documentation strings are included in the source, but
    excluded from export, in the interest of making this code block
    less noisy.


    Next, we define a function that is actually useful:
    =my-get-indirect-buffers-of=.

    #+HEADER: =my-get-indirect-buffers-of=
    #+NAME: lit-emacs-my-indirect-buffer-primitives-indirect-buffers-of
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (defun my-get-indirect-buffers-of (&optional buffer-or-name)
        "Return a list of all indirect buffers related to BUFFER-OR-NAME.

      If BUFFER-OR-NAME is an indirect buffer, all indirect buffers
      with the same base buffer as BUFFER-OR-NAME are returned.  This
      includes BUFFER-OR-NAME itself.

      If BUFFER-OR-NAME is not an indirect buffer, all indirect buffers
      with base buffer BUFFER-OR-NAME are returned.

      If BUFFER-OR-NAME is omitted or nil, the current buffer will be
      used instead.

      If BUFFER-OR-NAME is a string, but no buffer of that name exists,
      raise an error."
        (let* ((buf (my--get-buffer buffer-or-name))
               (basebuf (my--get-base-buffer-of-buffer buf))
               (different-base-buf-p
                (lambda(x)
                  (let* ((xbuf (my--get-buffer x))
                         (xbasebuf (my--get-base-buffer-of-buffer xbuf)))
                    ;; Exclude: 1. The base buffer itself.
                    ;;          2. Any buffer with a different base buffer.
                    ;; That leaves only those that are indirects with the
                    ;; base buffer in question.
                    (or (eq basebuf xbuf)
                        (not (eq basebuf xbasebuf)))))))
          (seq-remove different-base-buf-p (buffer-list))))
    #+END_SRC

    This function returns a list containing all indirect buffers that
    share their base buffer with the given one. If called with no
    argument, it computes the list of indirect buffers that share a
    base buffer with the current buffer.

    The resulting list will include the argument buffer if the
    argument buffer was an indirect buffer.


*** Creation and Destruction

    Before we define a way to create indirect buffers (beyond the
    =emacs= built-ins), let's define some convenient hooks.

    #+HEADER: My Indirect Buffer Hooks
    #+NAME: lit-emacs-my-clone-indirect-buffer-hooks
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (defun my--living-clones-kill-buffer-query-fun ()
        "Display a warning prompt about indirect buffers of the current buffer.

      For use with `kill-buffer-query-functions'.  Should not need to
      be called directly.  Nor should it need to be added or removed
      manually."
        (let ((buf (current-buffer)))
          (or
           (null (my-get-indirect-buffers-of buf))
           (y-or-n-p
            (concat "There appear to be live indirect buffers using"
                    (format " buffer %s as a base. Really kill it?"
                            buf))))))

      (defun my--clean-up-indirect-buffer-clone-hooks-hook()
        "Used in `my-clone-indirect-buffer-here'.

      Locally deletes itself from `clone-indirect-buffer-hook', and
      deletes `my--living-clones-kill-buffer-query-fun' from
      `kill-buffer-query-functions' when run.

      Should not need to be called or added/removed manually."
        (remove-hook 'kill-buffer-query-functions
                     #'my--living-clones-kill-buffer-query-fun
                     t)
        (remove-hook 'clone-indirect-buffer-hook
                     #'my--clean-up-indirect-buffer-clone-hooks-hook ;(selfCleanUpHook)
                     t))
    #+END_SRC

    The first hook adds an extra prompt to the affected buffer if that
    buffer has any indirect buffers when the user tries to kill it.

    The second hook deletes the first hook when present in a newly
    cloned indirect buffer. And it deletes itself: note the
    self-referentiality of line [[(selfCleanUpHook)]].

    Armed with those hooks we can define =my-clone-indirect-buffer-here=.

    #+HEADER: =my-clone-indirect-buffer-here=
    #+NAME: lit-emacs-my-clone-indirect-buffer-here
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (defun my-clone-indirect-buffer-here (newname)
        "Clone the current buffer and then display the clone in the current window.

      The new indirect buffer will be named NEWNAME, or will be
      generated by `clone-indirect-buffer' if nil was supplied.  When
      called interactively with a prefix argument, prompt for NEWNAME
      using the minibuffer.  Without a prefix argument, behave as if
      NEWNAME was nil.

      The newly created buffer is displayed in the current window using
      `switch-to-buffer'.

      Returns the buffer."
        (interactive
         ;; logic borrowed from clone-indirect-buffer      ;(cloneBufferHereArgParse)
         (progn
           (if (get major-mode 'no-clone-indirect)
               (error "Cannot indirectly clone a buffer in %s mode" mode-name))
           (list
            (when current-prefix-arg
              (read-buffer "Name of new indirect buffer: " (current-buffer))))))

        (let* ((newbuf (clone-indirect-buffer newname nil t))
               (basebuf (my--get-base-buffer)))
          (with-current-buffer basebuf
            (add-hook 'kill-buffer-query-functions
                      #'my--living-clones-kill-buffer-query-fun
                      nil
                      t)
            (add-hook 'clone-indirect-buffer-hook
                      #'my--clean-up-indirect-buffer-clone-hooks-hook
                      nil
                      t))
          (switch-to-buffer newbuf)))
    #+END_SRC

    Some interactive argument parsing logic from
    =clone-indirect-buffer= is duplicated [[(cloneBufferHereArgParse)][here]], but I see no great way
    to avoid doing this. We really /do/ need to check if the current
    major mode supports cloning before we do anything else.


    Lastly, we need a convenient way to kill a group of clone
    buffers. The way to do that is to kill the original one. To
    facilitate that we define =my-kill-base-buffer=, which finds the
    base buffer of the given buffer and calls =kill-buffer= on it.

    #+HEADER: =my-kill-base-buffer=
    #+NAME: lit-emacs-my-kill-base-buffer
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (defun my-kill-base-buffer (&optional buffer-or-name)
        "Kill the base buffer of BUFFER-OR-NAME.

      If BUFFER-OR-NAME was omitted or is nil, the base buffer of the
      current buffer is targeted instead.  See `buffer-base-buffer' and
      `kill-buffer' for details on what this means.

      If called interactively with a prefix argument, prompt for a
      buffer to target using the minibuffer.

      Returns t if a buffer was killed, nil otherwise."
        (interactive
         (list
          (when current-prefix-arg
            (read-buffer "Name of buffer to target: " (current-buffer) t))))
        (kill-buffer (my--get-base-buffer buffer-or-name)))
    #+END_SRC

    Obviously, this is reduces to just =kill-buffer= when the argument
    is not an indirect buffer. For an indirect buffer though, this
    really will kill it, its base buffer, and its siblings.


*** Keybindings: Indirect Buffers               :actual_keybind_loc:noexport:

    #+BEGIN_SRC emacs-lisp
    <<lit-emacs-indirect-buffer-key-binds>>
    #+END_SRC

** Emacs Server

   Should be booted up if it isn't already. Unless we're in
   =noninteractive= mode.

   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     ;; Start the server after init, unless we're in batch mode or
     ;; something.
     (use-package server
       :unless  noninteractive
       :no-require t
       :hook (after-init . server-start))
   #+END_SRC

** =pdf-tools=

   Not exactly basic, but I'd like to get this out of the way early,
   and I'm not sure where else to put it.

   Note that when this package is updated, the pdf-tools backends
   will need to be rebuilt. This rebuilding process will cause a
   prompt to appear in emacs, which means it may be unwise to start
   emacs as a daemon immediately after updating that package. Since
   you might not see the prompt.

   #+NAME: lit-emacs-init-pdf-tools
   #+BEGIN_SRC emacs-lisp +n
     (use-package pdf-occur
       :defer t
       :commands (pdf-occur-global-minor-mode))
     (use-package pdf-tools
       :defer t
       ;; Trick copied from the use-package README. This will load
       ;; pdf-tools just in time.
       :commands (pdf-tools-install)
       :magic ("%PDF" . pdf-view-mode)
       :config (pdf-tools-install))
   #+END_SRC

** Misc Look And Feel

*** =powerline= and =encourage=

    A pair of straight forward ui packages.

    #+NAME: lit-emacs-init-powerline-setup
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      ;; These don't do anything in non-interactive mode.
      (use-package powerline
        :defer t
        :hook (after-init . powerline-default-theme))
      ;; No real point in deferring this; it's tiny.
      (use-package encourage-mode
        :diminish)
    #+END_SRC

* Project Management

  Version control, project navigation, etc.

** =magit=

   The cleanest git interface I've yet to encounter.

   #+NAME: lit-emacs-init-magit-setup
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     (use-package magit
       :bind ("H-g" . magit-status)
       :config
       (use-package magit-commit
         :config
         (use-package git-commit))

       (use-package magit-files
         :commands (global-magit-file-mode)
         :config
         (global-magit-file-mode)))
   #+END_SRC

** =projectile=

   The project management package.

   #+NAME: lit-emacs-init-projectile-setup
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     (use-package projectile
       :defer 5 ;; Load unconditionally after 5 seconds
       :config (projectile-mode +1)
       :bind-keymap ("H-p" . projectile-command-map))               ;(projectileKeymap)
   #+END_SRC

   I'm defining how to access the ~projectile-mode-map~ [[(projectileKeymap)][here]] rather
   than any specific command, as that's the recommended way to set
   this up.




* Editing Functionality

  Packages related to code or text editing.

** General Editing Functionality



*** =company=

    Completion setup is fairly simplistic:

    #+NAME: lit-emacs-init-company-setup
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (use-package company
        :defer 2 ;; Load unconditionally after 2 sec
        :diminish company-mode
        :commands
        (company-abort
         company-complete-number
         global-company-mode)
        :bind (:map global-map
                    ("C-:" . company-complete))                ;(companyCompleteBind)
        :config
        ;; Taken from jweigley's dot-emacs repo.                        ;(jwRepoNote)

        ;; See http://oremacs.com/2017/12/27/company-numbers/
        (defun ora-company-number ()
          "Forward to `company-complete-number'.
        Unless the number is potentially part of the candidate.
        In that case, insert the number."
          (interactive)
          (let* ((k (this-command-keys))
                 (re (concat "^" company-prefix k)))
            (if (cl-find-if (lambda (s) (string-match re s))
                            company-candidates)
                (self-insert-command 1)
              (company-complete-number (string-to-number k)))))

        (let ((map company-active-map))
          (mapc
           (lambda (x)
             (define-key map (format "%d" x) 'ora-company-number))
           (number-sequence 0 9))
          (define-key map " " (lambda ()
                                (interactive)
                                (company-abort)
                                (self-insert-command 1))))
        (global-company-mode 1))

    #+END_SRC

    Some notes:

    - [[(companyCompleteBind)][This]] is not the only place where I make bindings
      related to the ~company-mode-map~.

    - All of the [[(jwRepoNote)][config code]] above was taken from John Weigley's
      [[https://github.com/jwiegley/dot-emacs][dot-emacs]] repository. From his =init.el= file specifically.

    - Which modes are affected by the =global-company-mode= is
      determined by a =custom= variable.

*** =pcomplete=

    Set up =pcomplete= as a =completion-at-point= function. =org=
    wants this, plus it gives me a neat way to add basic custom
    completion for certain basic things like =haskell= pragmas and the
    like. In general =pcomplete= can be useful to set up when the set
    of possible things to complete is small and the set of completions
    is small. It's sort of like the completion framework in
    =bash=. Dumb, but straight-forward.

    Note: This is very much /not/ a replacement for "real" completion
    facilities. I think more of it as being a useful way to add basic
    custom completion. Not totally unlike =abbrev=, but slightly
    cleverer.

    #+NAME: lit-emacs-init-pcomplete-setup
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"

      (use-package pcomplete
        :defer t
        :commands (pcomplete
                   pcomplete-completions-at-point
                   pcomplete--here
                   pcomplete-entries)
        :bind (:map global-map
                    ("H-! c <tab>" . pcomplete))
        ;; Tying the load to company-mode for now.
        :init
        (defun my-setup-pcomplete-capf-hook()
          (add-hook 'completion-at-point-functions #'pcomplete-completions-at-point))
        :config
        (unless (or (get 'pcomplete-default-completion-function 'saved-value)
                    (get 'pcomplete-default-completion-function 'themed-value))
          (mapc (apply-partially #'message "[init-general|pcomplete] %s")
                '(
      "pcomplete-default-completion-function appears to be set to it's default value!"
      "This is not advisable, as it won't compile and evaluate properly."
      "Attempting to set alternate value.."))
          (customize-set-variable
           'pcomplete-default-completion-function
           #'(lambda() (pcomplete-here (pcomplete-entries)))    ;(pcmp:defaultCmpDef)
           (concat "[init-general] Auto-replaced, to avoid "
                   "errors if `pcomplete.el' was loaded in "
                   "compiled form. Equivalent to the "
                   "original definition given in "
                   "`pcomplete.el'.")))
        (unless (or (get 'pcomplete-command-completion-function 'saved-value)
                    (get 'pcomplete-command-completion-function 'themed-value))
          (mapc (apply-partially #'message "[init-general|pcomplete] %s")
                '(
      "pcomplete-command-completion-function appears to be set to it's default value!"
      "This is not advisable, as it won't compile and evaluate properly."
      "Attempting to set alternate value.."))
          (customize-set-variable
           'pcomplete-command-completion-function
           #'(lambda () (pcomplete-here (pcomplete-executables)))
           (concat "[init-general] Auto-replaced, to avoid "
                   "errors if `pcomplete.el' was loaded in "
                   "compiled form. Equivalent to the "
                   "original definition given in "
                   "`pcomplete.el'.")))
        :hook (company-mode . my-setup-pcomplete-capf-hook))

    #+END_SRC



    *IMPORTANT NOTE*: Do /not/ use the default value for
    =pcomplete-default-completion-functions=, as it will misbehave and
    throw "invalid function" errors both when invoked using
    =pcomplete= and when used as a completion at point back-end for
    =company=. The [[(pcmp:defaultCmpDef)][lambda expression]] I substitute it with is precisely
    the same as the definition given in =pcomplete.el= except quoted
    in a slightly different way[fn:pcomp], which makes the
    byte-compiler do the right thing.

    If anyone reading this actually cares about the details of what
    this is fixing: the default value that =customize= ends up with if
    =pcomplete.el= is byte-compiled is the same lambda expression I've
    used in the code above, but with /only the lambda part
    byte-compiled!/ Meaning the =pcomplete-here= macro doesn't get
    compiled out of existence, which then leads to "invalid function
    pcomplete-here" errors when you try to invoke completion using
    =pcomplete=. If the expression is quoted as ='(lambda () ...)=,
    the byte compiler won't touch it which allows =emacs= to recognise
    that the expression inside the lambda is a macro and /not/ a
    function. Alternatively, if the expression is quoted as =#'(lambda
    () ...)=, the byte-compiler will instead compile both it /and/ its
    body, thus annihilating the macro completely and leaving us with a
    byte-compiled lambda wrapping some function calls. Either approach
    will solve the issue.

[fn:pcomp] or arguably the same way, but at a different time / in a
    different context. The order of operations and evaluation
    semantics involved in quoting/anti-quoting/macro-expansion/etc
    during compilation and their consequences for the meaning of an
    expression at run-time are subtle and treacherous.

*** =avy= editing/navigation

    #+NAME: lit-emacs-init-avy-prog-mode-setup
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      ;; Fast navigation and 'zap'-ing to specific nearby chars, with a
      ;; keyboard based "disambiguation" mode.
      (use-package avy                                                     ;(avyMode)
        :defer t
        :config (avy-setup-default)
        :bind (("C-'" . avy-goto-char-2)
               ("C-*" . avy-goto-subword-1)
               ("H-'" . avy-goto-char-in-line)))
      (use-package avy-zap
        :defer t
        :bind (("M-z" . avy-zap-up-to-char)
               ("M-Z" . avy-zap-to-char)))
    #+END_SRC


    For info on what [[(avyMode)][=avy=]] does exactly, see the built-in
    documentation or https://github.com/abo-abo/avy.



*** =flyspell= and =flycheck=

    #+NAME: lit-emacs-init-flyspell-flycheck-setup
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      ;; flyspell
      (use-package flyspell
        :diminish flyspell-prog-mode                            ;(flyspellProgMode)
        :diminish flyspell-mode
        :config
        ;; Delete some default bindings, to stop flyspell from eating up
        ;; keyboard real-estate that other modes (like org) could make much
        ;; better use of.  This needs to happen during config, since if I
        ;; modify the map before it's loaded, the modification won't stick.
        (unbind-key "C-c $" flyspell-mode-map)
        (unbind-key "C-M-i" flyspell-mode-map)
        ;; helm-flyspell overwrites this one anyway.
        (unbind-key "C-;" flyspell-mode-map)
        :hook ((prog-mode . flyspell-prog-mode)
               (text-mode . flyspell-mode)))

      ;; flycheck
      (use-package flycheck
        :hook ((prog-mode     . flycheck-mode)))
               ;(flycheck-mode . flycheck-cask-setup)))

      ;; pos-tip support for displaying flycheck errors
      (use-package pos-tip
        :defer t)
      (use-package flycheck-pos-tip
        :diminish
        :after (flycheck)
        :hook (flycheck-mode . flycheck-pos-tip-mode))

    #+END_SRC

    Note that ~flyspell-mode~ for /programming/ mode is a [[(flyspellProgMode)][different]]
    mode than the /text/ oriented one.





** Code Editing Functionality

   Firstly some general stuff:

   #+NAME: lit-emacs-init-delims-wc-etc-prog-mode-setup
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     (use-package rainbow-delimiters
       :hook (prog-mode . rainbow-delimiters-mode)
       :diminish)

     (use-package smartparens
       :hook (prog-mode . smartparens-mode)
       :diminish)

     (use-package column-enforce-mode
       :hook (prog-mode markdown-mode)
       :diminish)

     (use-package highlight-indentation
       :hook ((prog-mode . highlight-indentation-mode)
              (prog-mode . highlight-indentation-current-column-mode)
              (org-mode  . highlight-indentation-mode))
       :diminish highlight-indentation-mode
       :diminish highlight-indentation-current-column-mode)

     (use-package whitespace-cleanup-mode
       :hook (prog-mode org-mode)
       :diminish)
   #+END_SRC

   Delimiter and whitespace handling. Not all that exiting. And
   column-enforce also applies to =text-mode=.

*** Lang Major Modes

    Initialisation for specific programming language major modes. Many
    don't need anything specific, but a handful do.

    - Haskell

      Due to a key map conflict with ~haskell-interactive-mode~, I
      need to unset some bindings when ~haskell-mode~ loads.

      #+NAME: lit-emacs-init-haskell-mode
      #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
        (use-package haskell-mode
          :defer t
          :config
          (mapc (lambda (x) (define-key haskell-mode-map (kbd x) nil))
                '("C-c C-i"
                  "C-c C-l"
                  "C-c C-t"
                  "C-c C-b"
                  "C-c C-v")))

        (use-package flycheck-haskell
          :after (flycheck haskell-mode)
          :hook (haskell-mode . flycheck-haskell-setup))

      #+END_SRC


** Text Editing Functionality

   Not much text specific going on in this file. Just =pandoc=,
   basically.

   #+NAME: lit-emacs-init-pandoc-mode-setup
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     (use-package markdown-mode
       :config (use-package pandoc-mode
                 :commands pandoc-load-default-settings
                 :hook markdown-mode
                 :config (pandoc-load-default-settings)))
   #+END_SRC


* Changelog

  This is a local record of changes made to this file. May be inaccurate. I'm only human.


** Changes [2018-10-18 tor]

   - Removed the hook setting ~magit-last-seen-setup-instructions~ logic.

** Changes [2018-10-19 fre]

   - Substantial rewrites. Will add more commentary when I've had a look at the diff in git.
