#+TITLE: Helm Setup
#+Author: Nils Gustafsson
#+OPTIONS: num:3 toc:nil
#+TAGS: { export(e) noexport(n) } { out_of_seq_keybind(O) actual_keybind_loc(A) }
#+PROPERTY: header-args :noweb no-export :tangle yes :exports code :comments link :padline true

This file responsible is for initialising my ~helm~ setup, and is
imported in my [[file:init.org][init.org]] file. This is a literate =emacs lisp= file,
written in =org-mode=.

* Imports and Prerequisites

  - I want lexical scoping here.

    #+NAME: lit-emacs-helm-header
    #+BEGIN_SRC emacs-lisp -n -r -l ";(%s)" :comments no
    ;;; lit-emacs-init-general.el -*- lexical-binding: t -*-
    ;;; Commentary:
    ;;;
    ;;; Generated from lit-emacs-init-general.org
    #+END_SRC

  - This file needs access to the full =use-package= package when
    compiled.

    #+NAME: lit-emacs-helm-imports
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (eval-when-compile
        (require 'use-package))
    #+END_SRC

** Recompilation Code                                              :noexport:

   This code block may be evaluated to recompile and load this
   file. Useful to skip having to restart =emacs= to trigger
   recompilation.

   Note: This file currently has =:comments link= set. Take care if
   =org-id-link-to-org-use-id= is set to ~t~.

   #+BEGIN_SRC emacs-lisp :tangle no :exports none :noweb no :results value silent
     (let* ((this-file-base (expand-file-name "init/lit-emacs-init-helm"
                                              user-emacs-directory))
            (this-file-org (concat this-file-base ".org"))
            (this-file-el  (concat this-file-base ".el"))
            (tangled-file
             (car
              (org-babel-tangle-file this-file-org
                                     this-file-el
                                     "emacs-lisp"))))
       (and (byte-compile-file tangled-file t)
            (format "Tangled, compiled, and loaded %s"
             tangled-file)))
   #+END_SRC

* Helm

  My incremental search and completion framework of choice.

  There are two (-ish) things to set up here: =helm= itself, and the
  various =helm-*= packages for interacting with other packages via
  helm.


** Main Setup

   WRITTEN [2018-10-20 l√∂r 09:53]

   The only really noteworthy thing here is the use of =advice=,
   defined on line [[(helmCompReadAdvice)]], to make =helm= load on any use of
   =completing-read= or =read-file-name=. This ensures that those
   functions are "helm-ified" just in time, if =helm= hasn't been
   loaded already. The =advice= is removed as part of the
   =:config= step, when =helm= eventually loads.

   This setup leads to meaningless warnings from the byte-compiler
   though, which is why I claim that advice function is defined by the
   package in the =:functions= clause. It's almost true.

   Note: I'm forced to manually call =diminish= [[(helmExtraDiminish)][here]] to prevent the
   mode from getting "undiminished" by the advice. Not sure how to
   avoid that.

   #+NAME: lit-emacs-init-helm-main-setup
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"

     ;; Load helm
     (use-package helm
       ;; Load unconditionally after 5 seconds of idle time.
       :defer 5
       :ensure t
       :commands (helm-mode)
       ;; Hide the helm minor mode
       :diminish (helm-mode)
       ;; Prevent spurious warnings from the byte-compiler, by telling it a
       ;; white lie.
       :functions (my-init-completing-read-helm-advice)
       :bind (("C-s"     . helm-occur)
              ("M-x"     . helm-M-x)
              ("C-x C-f" . helm-find-files)
              ("C-x b"   . helm-buffers-list)
              ("<f6>"    . helm-execute-kmacro))
       :init
       (defun my-init-completing-read-helm-advice (&rest _args);(helmCompReadAdvice)
         "Advice for `completing-read' and `read-file-name' that
          forces `helm-mode' to activate. This advice removes itself
          from both functions when invoked. All arguments are ignored."
         (helm-mode 1)
         ;; This is neccesary, for reasons I'm not fully clear on. I guess
         ;; this function is somehow unaware of the :diminish above?
         (diminish 'helm-mode)                                  ;(helmExtraDiminish)
         (advice-remove 'completing-read
                        #'my-init-completing-read-helm-advice)
         (advice-remove 'read-file-name
                        #'my-init-completing-read-helm-advice))

       (defun my-init-completing-read-helm-advice-hook ()
         "Adds `my-init-completing-read-helm-advice' to the
          relevant functions after init."
         (advice-add 'completing-read
                     :before #'my-init-completing-read-helm-advice)
         (advice-add 'read-file-name
                     :before #'my-init-completing-read-helm-advice))

       :hook (after-init . my-init-completing-read-helm-advice-hook))

     ;; Load helm-ag
     (use-package helm-ag
           :after (helm)
           :ensure t
           :bind ("H-s" . helm-ag))

     ;; Load helm-org-rifle
     (use-package helm-org-rifle
       :after (helm org)
       :ensure t
       :bind ("H-A" . helm-org-rifle-agenda-files))

   #+END_SRC

   In addition, we could load and use =helm-dash= here, but I'm
   electing to leave that disabled (using ~:tangle no~) for now.

   #+NAME: lit-emacs-init-helm-main-dash-setup
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :tangle no
     (use-package helm-dash
       :defer t
       :after (helm)
       :ensure t
       :bind (("H-z a"   . helm-dash-activate-docset)
              ("H-z z"   . helm-dash)
              ("H-z H-z" . helm-dash-at-point)))
   #+END_SRC


** Crossover Setups

   There are a bunch of packages for interacting with other modes
   using helm. I use some of them.

   Note that all of the below declarations assume that =helm=
   autoloads are in scope. They do not, however, assume the same about
   the other packages they interact with. Hence the =:after (foo)=
   clauses.

   - =helm-flyspell=


     #+NAME: lit-emacs-init-helm-flyspell-setup
     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"

       (use-package helm-flyspell
         :defer t
         :ensure t
         :after (flyspell)
         :bind ("C-;" . helm-flyspell-correct))

     #+END_SRC

   - =helm-flycheck=


     #+NAME: lit-emacs-init-helm-flycheck-setup
     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"

       (use-package helm-flycheck
         :defer t
         :ensure t
         :after (flycheck)
         :bind ("C-c ! h" . helm-flycheck))

     #+END_SRC


   - =helm-projectile=

     It's not obvious from the code, but, *yes*, this does cause the
     =helm-projectile= keybinding remaps to come into effect just in
     time.

     #+NAME: lit-emacs-init-helm-projectile-setup
     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"

       (use-package helm-projectile
         :defer t
         :ensure t
         :commands (helm-projectile-on)
         :after (projectile)
         :init
         (eval-after-load 'projectile (lambda () (helm-projectile-on))))

     #+END_SRC


   - =helm-company=

     This adds a binding to the /active/ =company= map, which means
     the binding will be available only when a list of completions is
     visible. In other words, the binding allows me to turn a list of
     completions that is visible at the cursor into a searchable
     =helm= buffer. This is quite a handy tool to have around, should
     the list of possible completions happen to be very long.

     #+NAME: lit-emacs-init-helm-company-setup
     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"

       (use-package helm-company
         :defer t
         :ensure t
         :after (company)
         :bind (:map company-active-map
                     ("C-:" . helm-company)))

     #+END_SRC
