#+TITLE: Org Setup
#+Author: Nils Gustafsson
#+OPTIONS: num:3 toc:nil

This file responsible for initialising my personal =org= setup, and
should be imported from [[file:~/.emacs.d/init.el][init.el]]. This is a literate =emacs lisp= file,
written in =org-mode=.


* Org

  WRITTEN: [2018-10-18 tor 13:16]

  There's little to do here, besides importing org just to define some
  symbols. The one extra package I really want is a look and feel
  thing called =org-bullets=.

  #+NAME: lit-emacs-init-org-setup
  #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :noweb yes
    ;; Some scaffolding to help control and report local fixes.
    (eval-when-compile
      (require 'org)
      (defsubst org-version-fix-msg-named(version fixname)
        (message "[init-org] applying '%s' for org-version %s" fixname version))
      (defsubst org-version-fix-msg-unnamed(version)
        (message "[init-org] applying a nameless fix for org-version %s" version))
      (defmacro org-version-fix-msg(version &optional fixname)
        (if fixname
            `(org-version-fix-msg-named ,version ,fixname)
          `(org-version-fix-msg-unnamed ,version)))
      (defmacro when-org-version-is(short-version
                                    &optional fixname
                                    &rest true-forms)
        (if (string= (org-version) short-version)
            `(progn
               (org-version-fix-msg ,short-version ,fixname)
               ,@true-forms))))


    (use-package org
        :defer t
        :defines (org-agenda-mode-map)
        :commands(org-extract-archive-file
                  org-all-archive-files
                  org-at-property-p
                  org-up-heading-safe
                  org-capture)
        :preface
        (when-org-version-is
         "9.1.14"
         "org-all-archives-fix"
         <<org-all-archives-fix>>                            ;(Org:allArchivesFix)
         )
        :config
        <<org-config-defuns>>                                  ;(Org:configDefuns)
        :bind (:map org-mode-map
               ;; Narrowing and navigation.
               ("H-n f" . org-narrow-to-subtree)
               ("H-n t" . my-org-narrow-to-top-level-tree)
               ("H-n F" . org-narrow-to-defun)
               ("H-n e" . org-narrow-to-element)
               ("H-n b" . org-narrow-to-block)
               ("H-C-p" . org-previous-visible-heading)
               ("H-C-n" . org-next-visible-heading)
               ;; Clocking
               :map global-map
               ("H-o c l" . org-clock-in-last)
               ("H-o c o" . org-clock-out)
               ("H-o c q" . org-clock-cancel)
               ("H-o c j" . org-clock-goto) ;; Jump to currently clocked in heading
               ;; Capture
               ("H-o a" . org-capture) ;a as in "add"
               :map org-mode-map
               ("H-o c i" . org-clock-in)
               ("H-o c d" . org-clock-display)
               :map org-src-mode-map
               ("H-n f" . narrow-to-defun))
        :hook (org-mode . (lambda ()
                            (setq-local my-page-sep-special-prefix
                                        "* COMMENT"))))

    ;; So I won't have to keep staring at rows of asterisks.  Plus it
    ;; makes deeply nested trees (slightly) easier to deal with.
    (use-package org-bullets
      :defer t
      :commands org-bullets-mode
      :after org
      :hook (org-mode . (lambda () (org-bullets-mode 1))))

  #+END_SRC



  WRITTEN: [2018-10-26 fre 10:06]

  Line [[(Org:allArchivesFix)]]: I had to add a fix for a bit of broken
  code in my current =org= version. Will need to file a bug report
  about this. See the heading [[*Fix: =org-all-archive-files= is broken in][below]] for the actual body of the fix.


  WRITTEN: [2018-11-02 fre 09:03]

  Line [[(Org:configDefuns)]]: I've decided to add some personalised helper
  functions here, which I'm electing to define in a [[*Personal =org= Functions][node below]].

** Fix: =org-all-archive-files= is broken in 9.1.14

   The mistake was due to a use of =eq= for string comparison on line
   [[(allArchiveStringEqFix)]]. The original line is commented out just
   above it.

   #+NAME: Ã¶ot-emacs-init-org-archive-all-files-fix
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :tangle no :noweb-ref org-all-archives-fix
     ;; Copied from org-archive.el.
     ;; Modified to use the correct string comparison function.
     (defun my-org-all-archive-files ()
     "Get a list of all archive files used in the current buffer.

     This overrides the standard definition, to fix a mistaken use of
     `eq' for string equality in `org-all-archive-files' in version
     9.1.14 of `org'.  The mistake caused the function to fail to
     recognise :ARCHIVE: org properties, and thus to ignore archive
     files specified in such properties.

     This redefinition replaces the bad `eq' call with a call to
     `string=', which fixes the problem, and restores the expected
     behaviour."
     (let ((case-fold-search t)
       files)
       (org-with-wide-buffer
        (goto-char (point-min))
        (while (re-search-forward
            "^[ \t]*\\(#\\+\\|:\\)ARCHIVE:[ \t]+\\(.*\\)"
            nil t)
          (when (save-match-data
                  ;; CHANGED PART HERE
                  ;; Was: (if (eq (match-string 1) ":") (org-at-property-p)
                  (if (string= (match-string 1) ":") (org-at-property-p) ;(allArchiveStringEqFix)
                  ;; END OF CHANGE
            (eq (org-element-type (org-element-at-point)) 'keyword)))
        (let ((file (org-extract-archive-file
                 (match-string-no-properties 2))))
          (when (and (org-string-nw-p file) (file-exists-p file))
            (push file files))))))
       (setq files (nreverse files))
       (let ((file (org-extract-archive-file)))
         (when (and (org-string-nw-p file) (file-exists-p file))
       (push file files)))
       files))

     (advice-add 'org-all-archive-files
              :override
              #'my-org-all-archive-files)
   #+END_SRC

** Personal =org= Functions

   These are loaded during the =:init= or =:config= portions of the
   =use-package= declaration for [[*Org][=org=]] above.

   Firstly, I'd like a narrowing function that narrows to the current
   top-level tree.

   #+NAME: lit-emacs-init-org-config-defuns
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :tangle no :noweb-ref org-config-defuns
     (defun my-org-narrow-to-top-level-tree(&optional parent)
       "Widen, and narrow to the root of the current tree. If prefix
     arg PARENT is non-nil, narrow to the parent of the current node
     instead of the root of the tree."

       (interactive "P")
       (widen)
       (save-excursion
         (if (null parent)
             ;; Return to the root
             (while (org-up-heading-safe))
           ;; Move to parent
           (org-up-heading-safe))
         ;; When we''ve arrived:
         (org-narrow-to-subtree)))

   #+END_SRC

** Agenda Functions

   WRITTEN: [2018-10-17 ons 19:00]

   There are a couple of functions that need defining here, mainly for
   =org-agenda= use.

*** My agenda setup

    Firstly, I need a pair of helpers, [[(delBeforeShow)][one]] to clear the frame before
    opening the agenda, and [[(indirectHack)][one]] to give me a key binding for closing
    indirect buffers opened via an agenda view.

    #+NAME: lit-emacs-init-agenda-split-helpers-def
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :tangle no :noweb-ref org-agenda-helpers

      ;; Helper function for my-agenda-split-settings, defined further
      ;; down. Clears the frame of other buffers/windows before opening the
      ;; agenda in the current one.
      (defun my-agenda-del-before-show (&optional fe)             ;(delBeforeShow)
        "Like 'agenda-mode-show' but delete other buffers first."
        (interactive)
        (delete-other-windows)
        (org-agenda-show fe))

      ;; Tiny function to help close an indirect buffer opened from an
      ;; agenda buffer. Used in my-agenda-split-settings below.
      (defun my-agenda-del-indirect-hack ()                        ;(indirectHack)
        "Delete the window below, if it exists."
        (interactive)
        (when (with-demoted-errors "No valid buffer below! (Exact error: %s)"
                (windmove-down))
          (delete-window)))

    #+END_SRC

    And in addition, I
    need one tiny hook to make =org-agenda-mode= split windows in a
    way that I don't find deeply upsetting.

    #+NAME: lit-emacs-init-agenda-split-settings-def
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :tangle no :noweb-ref org-agenda-helpers
      ;; Adjust some agenda settings on the fly, when the mode is loaded.
      (defun my-agenda-split-settings ()
        "Set buffer-local split thresholds in agenda mode.
      Specifically: set 'split-height-threshold' to nil and
      'split-width-threshold' to 5.  Also redefines the goto key and
      switch to key."
        (interactive)
        (setq-local split-height-threshold nil)
        (setq-local split-width-threshold 5))
    #+END_SRC

    Armed with those, I can define setup the agenda to my liking:

    #+NAME: lig-emacs-init-agenda-agenda-split-settings-def
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :noweb yes
      (use-package org-agenda
        :defer t

        ;; Needed for autoloading, and making the byte-compiler happy.
        :commands (org-agenda-show)

        ;; Define helpers and hooks
        :init
        <<org-agenda-helpers>>

        :bind (:map org-agenda-mode-map
               ("RET"          . my-agenda-del-before-show)
               ("<return>"     . my-agenda-del-before-show)
               ("C-RET"        . org-agenda-goto)
               ("<C-return>"   . org-agenda-goto)
               ("C-M-RET"      . org-agenda-switch-to)
               ("<C-M-return>" . org-agenda-switch-to)
               ("<tab>"        . org-agenda-tree-to-indirect-buffer)
               ("<backtab>"    . my-agenda-del-indirect-hack))

        :hook (org-agenda-mode . my-agenda-split-settings))

      ;; Add the above to the agenda-mode-hook.
      ;(add-hook 'org-agenda-mode-hook 'my-agenda-split-settings)

     #+END_SRC


*** Agenda view opening functions

    Some functions which mimic the agenda key bindings connected to
    two agenda views I make frequent use of.

    #+NAME: lit-emacs-init-agenda-view-open-functions-def
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"

      ;; Open the views in question

      (defun my-agenda-custom-view-general (&optional arg)
        "Show the ;; view, passing along optional ARG."
        (interactive "P")
        (org-agenda arg ";;"))

      (defun my-agenda-custom-view-work (&optional arg)
        "Show the ;W view, passing along optional ARG."
        (interactive "P")
        (org-agenda arg ";W"))


      ;; Open and bury

      (defun my-agenda-custom-view-general-and-bury (&optional arg)
        "Show the ;; view, passing along optional ARG, then bury the buffer."
        (interactive "P")
        (org-agenda arg ";;")
        (bury-buffer))


      (defun my-agenda-custom-view-work-and-bury (&optional arg)
        "Show the ;W view, passing along optional ARG, then bury the buffer."
        (interactive "P")
        (org-agenda arg ";W")
        (bury-buffer))

    #+END_SRC


*** Idle timers

    I like having =emacs= construct my agenda buffers for me, if I'm
    ever idle (in emacs) for significant periods of time.

    #+NAME: lit-emacs-init-agenda-timers-setup
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      ;; Show work or general agenda depending on current date/time.
      (defun my-show-agenda-special (&optional arg)
        "Show the work or general agenda depending on the weekday and
      current time, passing ARG along as appropriate."
        (deactivate-mark)
        (let ((dayOfWeek (string-to-number (format-time-string "%u")))
              (timeOfDay (string-to-number (format-time-string "%H"))))
          (if (or (= dayOfWeek 6)
                  (= dayOfWeek 7)
                  (< timeOfDay 7)
                  (> timeOfDay 17))
              (my-agenda-custom-view-general arg)
            (my-agenda-custom-view-work arg)))
        (goto-char (point-min)))


      ;; Show/Update agenda every 2 minutes after an initial period of 5
      ;; minutes of idleness.
      (defvar my-agenda-idle-update-resume-timer nil
        "Timer for `my-agenda-idle-maybe-update' to reschedule itself, or nil.")

      (defun my-agenda-idle-update ()
        "Run `org-agenda-redo' every 2 minutes, if idle.

      Stop doing this after 6 hours of idleness"

        (when my-agenda-idle-update-resume-timer
          (cancel-timer my-agenda-idle-update-resume-timer))

        ;; Display agenda.
        (let ((target-frame (car (visible-frame-list))))
          (if (null target-frame)
              (message "update-agenda-idle-timer: no visible frames; skipping update")
            ;; Not sure if I need to do this, but I might as well.
            (raise-frame target-frame)
            (message "update-agenda-idle-timer: updating agenda..")
            (my-show-agenda-special)
            (when org-agenda-sticky
              (org-agenda-redo))))

        ;; Don't reschedule if it's been more than 6 six hours.
        (unless (time-less-p (seconds-to-time (* 6 3600))
                             (current-idle-time))

          (let ((timeincr (if (time-less-p (seconds-to-time (* 2 3600))
                                           (current-idle-time))
                              ;; if it's been more than two hours: update
                              ;; once every 15 min.
                              (* 15 60)
                            ;; else: update every 2 minutes
                            120)))

            (setq my-agenda-idle-update-resume-timer
                  (run-with-idle-timer
                   (time-add (current-idle-time) timeincr)
                   nil
                   #'my-agenda-idle-update)))))

      ;; Starts after 5 minutes.
      (run-with-idle-timer 300 t #'my-agenda-idle-update)
    #+END_SRC
