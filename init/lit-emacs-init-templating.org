#+TITLE: Template And Snippet Init
#+Author: Nils Gustafsson
#+OPTIONS: num:3 toc:nil
#+TAGS: { export(e) noexport(n) } { out_of_seq_keybind(O) actual_keybind_loc(A) }
#+PROPERTY: header-args :noweb no-export :tangle yes :exports code :comments link :padline true

This file is part of my =emacs= init setup, and should be imported in
[[file:~/.emacs.d/init.el][init.el]]. This is a literate =emacs lisp= file, written in =org-mode=.

* Imports and Prerequisites

  - I want lexical scoping here.

    #+NAME: lit-emacs-templating-header
    #+BEGIN_SRC emacs-lisp -n -r -l ";(%s)" :comments no
    ;;; lit-emacs-init-general.el -*- lexical-binding: t -*-
    ;;; Commentary:
    ;;;
    ;;; Generated from lit-emacs-init-general.org
    #+END_SRC

  - This file needs access to the full =use-package= package when
    compiled.

    #+NAME: lit-emacs-templating-imports
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (eval-when-compile
        (require 'use-package))
    #+END_SRC


* =yasnippet=

  Setting up =yasnippet= itself, along with =auto-yasnippet= is
  straight forward:

  #+NAME: lit-emacs-init-yasnippet-setup
  #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
    ;; yasnippet
    (use-package yasnippet
      :diminish yas-minor-mode
      ;; Load eagerly, this needs to be active, and fail fast if it's
      ;; broken. Snippets are loaded just in time, anyway.
      :demand t
      ;; Bindings copied from jweigley's dot-emacs.
      :bind (("C-c y d" . yas-load-directory)
             ("C-c y i" . yas-insert-snippet)
             ("C-c y f" . yas-visit-snippet-file)
             ("C-c y n" . yas-new-snippet)
             ("C-c y t" . yas-tryout-snippet)
             ("C-c y l" . yas-describe-tables)
             ("C-c y g" . yas-global-mode)
             ("C-c y m" . yas-minor-mode)
             ("C-c y a" . yas-reload-all)
             ("C-c y x" . yas-expand))
      :config
      (yas-global-mode 1))

    ;; aya
    (use-package auto-yasnippet
      :defer t
      :after (yasnippet)
      :bind (("H-w" . aya-create)
             ("H-y" . aya-expand)))

    ;; helm source for yasnippet
    (use-package helm-c-yasnippet                             ;(helmCYasnippetLoad)
      :defer t
      :after (helm yasnippet)
      :bind ("C-c y :" . helm-yas-complete))

  #+END_SRC

** TODO Add a binding for =helm-c-yasnippet=?

   The package is loaded [[(helmCYasnippetLoad)][here]], but I don't have a specific binding set
   up to use it. May be worth considering.


* =yatemplate=

  I've elected to put this under it's own heading, as it requires some
  specific setup. =yatemplate= basically combines ~auto-insert~ with
  ~yasnippet~, allowing you to have file templates with ~yasnippet~
  code inside them.

** TODO Checking the templates

   Firstly, I'd like to have a function to check that the template
   directory exists, and that the templates within it have reasonable
   names. =yatemplate= prefers templates to have names of the form

       #+NAME: lit-emacs-init-yatemplate-filename-grammar
       #+BEGIN_VERBATIM

       <TEMPLATE_NAME> := <NUMBER><SEP><REGEX_NAME>

       <NUMBER> := {x | x matches '[0-9]+'}

       <COLON>  := <VAR:yatemplate-separator>

       <REGEX_NAME> := { "valid regex that doesn't end with a '$' character" }
       #+END_VERBATIM

    where

    - =x matches '[0-9]+'= should be understood to mean "x matches the
      regular expression =[0-9]+="

    - =<VAR:foo>= should be understood to mean "the value of the
      variable 'foo' in emacs"


    and the definition of =<REGEX_NAME>= is hopefully
    self-explanatory.

    So lets check write such a function. Here's a very basic version:

    #+NAME: lit-emacs-init-check-yatemplate-dir-def
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :tangle no
      (defun nilgu/check-yatemplate-dir ()
        "Verify that the template dir exists and contains reasonable files.
      This entails checking that the directory exists, that the files within
      have reasonable names, and that those files are actual text files.

      Note: This won't catch malformed regex sequences in filenames."
        (let ((warnprfx "from lit-emacs-init-templating:"))
          (if (file-directory-p yatemplate-dir)
              ;; It's a directory
              (let ((badfiles (seq-filter
                               (not (string-match-p
                                     (format "[0-9]+%c.+[^$]" yatemplate-separator)))
                               (directory-files yatemplate-dir))))
                ;; If one or more files are malformed
                (unless (null badfiles)
                  (mapc (lambda (x)
                          (message
                           (format
                            "%s found malformed filename in yatemplate-dir: %s"
                            warnprfx
                            x)))
                        badfiles)))
            ;; It's not a directory
            (message
             (format
              "%s the value of yatemplate-dir, '%s', isn't a directory!"
              warnprfx
              yatemplate-dir)))))
    #+END_SRC

    Not fully satisfied with this, as it doesn't handle the filenames
    quite right. We should split on the first instance of
    ~yatemplate-separator~, and /then/ attempt a regex match.

    A more sensible approach might be to add a function that verifies
    that all of ~auto-insert-alist~ is well formed after populating
    it, rather than checking the filenames themselves.

    Leaving this untangled for now.

** Setup

   The package itself is easy to load:

   #+NAME: lit-emacs-init-yatemplate-setup
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     (use-package yatemplate
       :defer t
       :commands yatemplate-fill-alist
       :init
       (eval-after-load 'auto-insert
         #'yatemplate-fill-alist)
       :hook (find-file  . auto-insert))
   #+END_SRC

   The above setup runs on an ~after-init-hook~, because the behaviour
   depends on variables acquired from the =custom= file.
