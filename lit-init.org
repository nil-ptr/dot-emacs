#+TITLE: Main Emacs Initialisation File
#+Author: Nils Gustafsson
#+STARTUP: nologrefile
#+OPTIONS: num:3
#+TAGS: { export(e) noexport(n) } { out_of_seq_keybind(O) actual_keybind_loc(A) }
#+PROPERTY: header-args :noweb no-export :exports code :comments link :padline true :tangle yes

* Imports and Prerequisites

  - I want lexical scoping here.

    #+NAME: lit-init-header
    #+BEGIN_SRC emacs-lisp -n -r -l ";(%s)" :comments no
    ;;; lit-init.el -*- lexical-binding: t -*-
    ;;; Commentary:
    ;;;
    ;;; Generated from lit-init.org
    #+END_SRC

  - This file needs access to the full =use-package= package when
    compiled. And I need =init-say= from my init macros.

    #+NAME: lit-init-compile-time-imports
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (eval-when-compile
        (require 'use-package)
        (require 'my-init-macros)
        (def-init-say "lit-init" "info"))
    #+END_SRC

** A note for readers

   WRITTEN: [2019-05-08 ons]

   Some sections, such as [[*Indirect Buffers]], start with a list of key
   bindings for functions which are really defined in various
   locations throughout that section as a whole. These key bindings
   are displayed first, because they provide a nice quick overview of
   the main commands to be defined in the given section.

   The /actual/ site at which such a block is typically going to end
   up when source code is extracted from the original =org= file, is
   at the very end of the same section of the file. Sections with out
   of sequence key binding blocks in them are tagged with
   ~out_of_seq_keybind~ tags. The sections where these bindings
   /actually/ occur are not included when documentation is exported
   from this =org= file, but are tagged with ~actual_keybind_loc~ (and
   also ~noexport~) in the =org= source.



** Recompilation Code                                              :noexport:

   This code block may be evaluated to recompile and load this
   file. Useful to skip having to restart =emacs= to trigger
   recompilation.

   Note: This file currently has =:comments link= set. Take care if
   =org-id-link-to-org-use-id= is set to ~t~.

   #+BEGIN_SRC emacs-lisp :tangle no :exports none :noweb no :results value silent
     (let* ((this-file-base (expand-file-name "lit-init"
                                              user-emacs-directory))
            (this-file-org (concat this-file-base ".org"))
            (this-file-el  (concat this-file-base ".el"))
            (basebuf (or (buffer-base-buffer (current-buffer)) (current-buffer)))
            (tangled-file
             (progn
               (with-current-buffer basebuf (widen))
               (car
                (org-babel-tangle-file this-file-org
                                       this-file-el
                                       "emacs-lisp")))))
       (and (byte-compile-file tangled-file t)
            (format "Tangled, compiled, and loaded %s"
             tangled-file)))
   #+END_SRC

* Basic Emacs Initialisation

  Some basic things I need out of the way.

** Basic Window and Buffer Keys

   Firstly, some window-related stuff. I need a function to split the
   frame into three side-by-side windows, because that's my preferred
   default layout.

   #+NAME: lit-emacs-my-split-to-3-windows
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     (defun my-split-to-3-windows ()                                 ;(defNilguSplitwin)
       "Splits the current window until this frame has 3 and then balances them."
       (interactive)
       (let ((num (- 3 (count-windows))))
         (when (> num 0)
           (dotimes (_i num) (split-window-right nil))
           (balance-windows))))
   #+END_SRC

   And here are my global keys for window/buffer movment:

   #+NAME: lit-emacs-init-window-keybinds
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     ;; Window/buffer manipulation
     (use-package buffer-move
       :defer t
       :ensure t
       :bind (:map global-map
                   ("C-H-<left>"  . buf-move-left)
                   ("C-H-<right>" . buf-move-right)
                   ("C-H-<up>"    . buf-move-up)
                   ("C-H-<down>"  . buf-move-down)))
     (bind-keys
      :map global-map
      ("H-<left>"  . windmove-left)
      ("H-<right>" . windmove-right)
      ("H-<up>"    . windmove-up)
      ("H-<down>"  . windmove-down)
      ("C-x C-M-s" . my-split-to-3-windows)                         ;(splitwinBind)

      ;; Save, exit, and kill the server
      ("C-x C-M-c" . save-buffers-kill-emacs)                  ;(savebuffkillemacs)

      ;; Delete the current frame.
      ("H-q" . delete-frame)

      ;; Better keybinding for dabbrev-expand, as "M-\" is awkward on a
      ;; nordic keyboard.
      ("H-:"       . dabbrev-expand)

      ;; Useful command for basic code formatting. Especially for
      ;; struct/record layouts, list/map literals and the like.
      ("C-c a"     . align-regexp)                               ;(alignregexpBind)

      ;; Narrowing keys. See also my org settings.
      ("H-n n"     . narrow-to-region)
      ("H-n f"     . narrow-to-defun)
      ("H-n P"     . narrow-to-page)
      ;; Undo the narrowing.
      ("H-n w"     . widen))

   #+END_SRC

   Two noteworthy lines above are line [[(splitwinBind)]], in which I make
   use of [[(defNilguSplitwin)][my-split-to-3-windows]], and line [[(savebuffkillemacs)]] which sets up a
   binding for killing the current client /and/ the server.

   Additionally, there's a binding for [[(alignregexpBind)][align-regexp]], which is a handy
   tool to have for quick ad-hoc code formatting. Can be combined with
   a prefix argument. for a more powerful version of the command.

   A further note: the "H" in the keybindings above refers to the
   "Hyper" key, which is what I've reassigned capslock to. Because who
   even uses capslock?


** Narrowing and Pages

   The narrowing and page ideas in =emacs= are neat, but inserting
   form feed characters in to source code willy nilly makes me a
   little uncomfortable.

   So, based on the ideas in page.el, I'll implement my own substitutes.

*** =my-page-sep=: Definition

    First, let's define what my page separators even are:

    #+NAME: lit-emacs-init-page-sep-def
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (defvar my-page-sep-special-prefix nil
        "Special prefix to be used instead of `comment-start' in `my-page-sep'.

      Default value is nil, meaning no special prefix. This is the
      right choice in most modes.

      When this is non-nil it should be a string CONTAINING NO
      LINEBREAKS, and will replace the `comment-start' as the starting
      token for a `my-page-sep'. Setting it to a non-nil value also
      causes the end token of `my-page-sep' to be omitted entirely.")

      (eval-when-compile

        (defsubst my--page-sep-trim-start(s)
          (string-trim-left
           (if (< 0 (- (length s)
                       (length (string-trim-right s))))
               s
             (concat s " "))))

        ;; For §- (section separator)
        (defsubst my--page-sep-start-tok()
          (cond
           ;; Use the special prefix if it exists
           (my-page-sep-special-prefix
            (my--page-sep-trim-start my-page-sep-special-prefix))
           ;; If not, use comment-start
           (comment-start
            (my--page-sep-trim-start comment-start))
           ;; Use the empty string if it does not
            (t "")))


        (defsubst my--page-sep-end-tok()
          ;; 1. If my-page-sep-special-prefix is non-nil, ignore this token
          ;; completely.
          ;;
          ;; 2. I check for comment-start rather than comment-end here
          ;; because I don't know how I'd even begin to interpret what it
          ;; would mean for comment-end to be well defined when
          ;; comment-start is not.
          (if (and (not my-page-sep-special-prefix)
                   comment-start)
              (string-trim-right
               ;; Don't use comment-end if it's the empty string
               (if (and comment-end (not (string= comment-end "")))
                   (if (< 0 (- (length comment-end)
                               (length (string-trim-left comment-end))))
                       comment-end
                     (concat " " comment-end))
                 ;; If comment-end is nil or "" use a backwards start-tok
                 (reverse (my--page-sep-start-tok))))
            ;; Return an empty string if comment-start was nil
            ""))

        (defconst my--page-sep-center-tok
                "§ ────────── ────────── ────────── ────────── ──────────"))

      (defmacro my-page-sep-length()
        "Compute the length of the output of `my-page-sep'."
        `(+ (length (my--page-sep-start-tok))
            ,(length my--page-sep-center-tok)
            (length (my--page-sep-end-tok))))

      (defmacro my-page-sep()
        "My page separator token.

      See `insert-my-page-sep', `my-at-page-sep-p', `my-forward-page',
      `my-backward-page', and `my-narrow-to-page'."
        `(concat
          (my--page-sep-start-tok)
          ,my--page-sep-center-tok
          (my--page-sep-end-tok)))

    #+END_SRC

    The above snippet defines the separator and it's length as a pair
    of macros, since the exact value is going to depend on the local
    comment syntax.

    Next, I need some simple functions to insert and detect these:

    #+NAME: lit-emacs-init-page-sep-defuns
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      ;; TODO: allow trailing whitespace?
      (defun my-at-page-sep-p()
        "Return t if the current line contains a valid page separator.

      A valid page separator consists of a `comment-start' followed by
      a space (if needed), and the string \"§ ────────── ────────── ────────── ────────── ──────────\",
       followed by a space (if needed) and a `comment-end`, or, if
      `comment-end' is nil/empty, a reversed `comment-start'.

      If this explanation seems unclear, try invoking
      `my-insert-page-sep' to see an actual example."
        (save-excursion
          (beginning-of-line)
          (let ((sep (my-page-sep))
                (here (point))
                (there (progn (end-of-line) (point))))
            ;; Evaluates to nil if there is beyond the end of the buffer, or
            ;; the buffer-substring from here to there isn't the separator.
            (and (> (point-max) there)
                 (string= sep
                          (buffer-substring here
                                            there))))))
      (defun my-insert-page-sep()
        "Insert a page separator at the beginning of the current line.

      Any preexisting content on the line, including the cursor, is
      moved to the next line but is otherwise unchanged."
        (interactive)
        ;; Remember where we were, so we can move the point back to the same
        ;; column
        (let ((col (current-column)))
          (beginning-of-line)
          (insert (my-page-sep))
          (newline)
          (move-to-column col)))

      (defun my-count-lines-page()
        "Similar to `count-lines-page', but using `my-page-sep'.

      Displays the total number number of lines from the start of the
      current page up to the end of the current page. In parenthesis
      are:

      A. the number of lines from the start of the current page up to,
      but not including, the current line.
      B. the number one (representing the current line).
      C. the number of lines from the line following the current one to
      the end of the page.

      In other words the lines before point and lines after point will
      sum to 1 less than the number of lines in the page. So if the
      point is on the 4th line of a 5 line page, the output should look
      like this:

       \"Page has 5 (3 + 1 + 1) lines\".

      If the point is on a page separator, \"At page separator\" will
      be displayed instead.

      See `my-at-page-sep-p' for a simple description of what the
      separator looks like."
        (interactive)
        (if (my-at-page-sep-p)
            (message "At page separator")
          (save-excursion
            (let ((here (line-number-at-pos))                        ;(psepCountLines)
                  (bot (progn
                         (my-forward-page)
                         (when (my-at-page-sep-p)
                           (backward-char))
                         (line-number-at-pos)))
                  (top (progn
                         (my-backward-page)
                         (when (my-at-page-sep-p) (forward-line))
                         (line-number-at-pos) )))
              (message "Page has %d (%d + 1 + %d) lines"
                       (+ (- bot top) 1)
                       (- here top)
                       (- bot here))))))

      (bind-keys :map global-map
                 ("H-- -" . my-insert-page-sep)
                 ("H-- l" . my-count-lines-page))

    #+END_SRC

    I've elected to bind this to an available global binding, because
    I'll probably want to use it a lot.

    One thing worth noting in the above block is the use of
    =backward-char= and =forward-line= in the [[(psepCountLines)][let binding]] in
    =my-count-lines-page=, which is meant to exclude the page
    separators themselves. The exact same logic is going to show up in
    =my-narrow-to-page= in the next section, except there we also
    employ =forward-line= to exclude the starting page separator as
    well. Note also, that 1 is added to the "line total",

*** =my-page-sep=: Navigation and Narrowing

    So.. how /does/ one make use of these? By using them as anchors
    for navigation, and narrowing.

    In order to do that though, I need to define two basic primitives:
    #+NAME: lit-emacs-init-page-sep-nav-and-narrow-prim
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (eval-when-compile
        (defsubst my--to-next-page-sep-forward()
          (end-of-line)                                             ;(psepForwardEOL)
          (search-forward (my-page-sep) nil 'move)
          (while (not (or (eobp)
                          (my-at-page-sep-p)))
            (search-forward (my-page-sep) nil 'move))
          (beginning-of-line)                                       ;(psepForwardBOL)
          (point))

        (defsubst my--to-next-page-sep-backward()
          (search-backward (my-page-sep) nil 'move)
          (while (not (or (bobp)
                          (my-at-page-sep-p)))
            (search-backward (my-page-sep) nil 'move))
          (point)))
    #+END_SRC

    Note the use of [[(psepForwardEOL)][=end-of-line=]] and [[(psepForwardBOL)][=beginning-of-line=]]
    here. They're needed because =search-forward= with a non-nil-non-t
    3rd argument places the point /at the end of the match/, which is
    not where I want to be. To be specific, the =end-of-line= bit is
    there to compensate for the =beginning-of-line= bit which would
    cause a "movement loop" with =search-forward= if we're already at
    a page separator. The net result is a little bit of wasted
    movement work, but I don't think that matters much for a function
    that's almost exclusively going to be invoked by user input. The
    user won't notice the delay.

    =search-backward= already puts the point at the beginning of the
    match, so the corresponding shenanigans aren't necessary there.


    I can now define the actual user-facing "page forward" and "page
    backward" functions. I'm following the standard nomenclature used
    in =page.el= here: "forward-page" and "backward-page".

    #+NAME: lit-emacs-init-page-sep-nav
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"

      ;; mimics the forward-page function
      (defun my-forward-page(&optional count)
        "Move to the beginning of the first `my-page-sep' after point.
      If no page separator is found after point, move to the end of the
      buffer instead.

      With optional argument COUNT: repeat COUNT times. A negative
      COUNT is taken to mean \"move to the beginning of the previous\"
      `my-page-sep' instead.

      With a COUNT of 0, nothing is done.

      If called interactively, COUNT may be specified as a numeric prefix."
        (interactive "p")
        (setq count (or count 1))
        (if (< count 0)
            (while (and (< count 0) (not (bobp)))
              (setq count (1+ count))
              (my--to-next-page-sep-backward))
          (while (and (> count 0) (not (eobp)))
            (setq count (1- count))
            (my--to-next-page-sep-forward))))

      ;; mimics the backward-page function
      (defun my-backward-page(&optional count)
        "Move to the beginning of the first `my-page-sep' before point.
      If no page separator is found before point, move to the beginning
      of the buffer instead.

      This function is exactly identical to `my-forward-page' with a
      negative argument."
        (interactive "p")
        (setq count (or count 1))
        (my-forward-page (- count)))                                    ;(myBackPage)

    #+END_SRC

    Nothing all that noteworthy about these definitions, aside from
    =my-backward-page= being pretty much just an [[(myBackPage)][alias for
    =my-forward-page=]] with a negative argument.

    Having done that, we define a narrowing function using my page
    separators.

    #+NAME: lit-emacs-init-page-sep-narrow
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"

      ;; Narrowing!
      (defun my-narrow-to-page()
        "Like `narrow-to-page', but using `my-page-sep'.

      See `my-at-page-sep-p' for a simple description of what the
      separators look like.

      Briefly: This function finds the next page separator after point,
      then the first page separator preceding that one, and invokes
      `narrow-to-region' to narrow the buffer to everything between
      those two separators apart from the separators themselves."
        (interactive)
        (save-excursion
          (my-forward-page)
          (when (not (eobp))
            ;; go back one char, to reach the end of the previous line
            (backward-char))
          (narrow-to-region
           (point)
           (progn
             (my-backward-page)
             (when (not (bobp))
               ;; go to the next line (we're already at the left margin)
               (forward-line))
             (point)))))

    #+END_SRC


    And versions of =my-forward-page= and =my-backward-page= that
    widen and then narrow to the arrived at page.

    #+NAME: liet-emacs-init-page-sep-narrow-nav
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (defun my-forward-narrow-page (&optional count)
        "Like `my-forward-page', except it narrows to the target page.

      Additionally it will widen the current buffer before
      moving, COUNT is treated the same way as it is in
      `my-forward-page'."
        (interactive "p")
        (widen)
        (setq count (or count 1))
        (my-forward-page count)
        (my-narrow-to-page))

      (defun my-backward-narrow-page (&optional count)
        "Like `my-backward-page' except it narrows to the target page.

      Additionally it will widen the current buffer before
      moving, COUNT is treated the same way as it is in
      `my-backward-page'."
        (interactive "p")
        (widen)
        (setq count (or count 1))
        ;; An extra + 1 is needed here, for us to narrow to the correct
        ;; page.
        (my-backward-page (+ 1 count))                             ;(backwardsOffset)
        (my-narrow-to-page))
    #+END_SRC

    A note regarding [[(backwardsOffset)]]: =my-backward-page= moves to
    the beginning of the /current/ page, or if we're already there the
    beginning of the page before that. But moving to the beginning of
    the current page and re-narrowing would be unhelpful. Thus we move
    an extra page backwards, so that it really always tries to narrow
    to the page /before/ the current one.


    Lastly, let's bind these things to some keys.

    #+NAME: lit-emacs-init-page-sep-bind-keys
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      ;; Bind some keys
      (bind-keys :map global-map
                 ;; next/prior is page up / page down
                 ("H-<next>" . my-forward-page)
                 ("H-<prior>" . my-backward-page)
                 ("C-H-<next>" . my-forward-narrow-page)
                 ("C-H-<prior>" . my-backward-narrow-page)
                 ;; Mirrors the binding for narrow-to-page.
                 ("H-n p" . my-narrow-to-page)
                 ;; Is consistent with "H-- -" and "H-- l" defined earlier.
                 ("H-- n" . my-narrow-to-page))
    #+END_SRC


** Indirect Buffers                                      :out_of_seq_keybind:

   WRITTEN: [2019-05-08 ons]

   Another interesting bit of functionality in =emacs= is the notion
   of an indirect buffer. In this section I define some nice helpers
   and a few hooks to make indirect buffers a little easier to make
   and use.


   #+HEADER: Commands defined in this section
   #+NAME: lit-emacs-indirect-buffer-key-binds
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :tangle no
     (bind-keys
      :map global-map

      ;; Clone the current buffer and switch to the clone.
      ("H-b c" . my-clone-indirect-buffer)

      ;; Make the current view unique.
      ("H-b u" . my-make-current-view-unique)

      ;; Switch to a different buffer with the same base buffer.
      ("H-b b" . my-switch-to-buffer-with-base-buffer-of)

      ;; Kill the base buffer of the current buffer.
      ("H-b K" . my-kill-base-buffer)
      ;; Switch to the base of the current buffer and kill all indirect
      ;; buffers.
      ("H-b k" . my-kill-indirect-buffers-of))
   #+END_SRC

*** Primitives

    Let's start off with some low level primitives.

    #+NAME: lit-emacs-indirect-buffer-compile-primitives
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (eval-when-compile
        (defsubst my--get-base-buffer-of-buffer (&optional buffer)
      <<my--get-base-buffer-of-buffer-doc-string>>
          (or (buffer-base-buffer
               (or buffer
                   (current-buffer)))
              buffer))

        (defsubst my--get-buffer (&optional buffer-or-name)
      <<my--get-buffer-doc-string>>
          (get-buffer
           (or buffer-or-name
               (current-buffer))))

        (defsubst my--get-buffer-or-err (&optional buffer-or-name)
      <<my--get-buffer-or-err-doc-string>>
          (or (my--get-buffer buffer-or-name)
              (error "No such buffer: %s" buffer-or-name)))

        (defsubst my--get-base-buffer (&optional buffer-or-name)
      <<my--get-base-buffer-doc-string>>
          (my--get-base-buffer-of-buffer
           (my--get-buffer buffer-or-name)))

        (defsubst my--base-buffer-is-p (base buffer)
      <<my--base-buffer-is-p-doc-string>>
            (eq (my--get-base-buffer buffer) base)))
    #+END_SRC

    #+NAME: my--get-base-buffer-of-buffer-doc-string
    #+BEGIN_SRC emacs-lisp :exports none :tangle no
              "Returns the base buffer of BUFFER.

      If BUFFER is not an indirect buffer, return BUFFER.

      If BUFFER is omitted or nil, return the base buffer of the
      current buffer.

      The return value from this function is always a buffer object."
    #+END_SRC

    #+NAME: my--get-buffer-doc-string
    #+BEGIN_SRC emacs-lisp :exports none :tangle no
              "Return the buffer named BUFFER-OR-NAME.

      BUFFER-OR-NAME must be a string or a buffer.

      If BUFFER-OR-NAME is a string and there is no buffer named
      BUFFER-OR-NAME, return nil.

      If BUFFER-OR-NAME is a buffer, return BUFFER-OR-NAME.

      If BUFFER-OR-NAME is omitted or nil, return the current buffer.

      This function is equivalent to `get-buffer' except the
      BUFFER-OR-NAME argument is optional."
    #+END_SRC

    #+NAME: my--get-buffer-or-err-doc-string
    #+BEGIN_SRC emacs-lisp :exports none :tangle no
              "Return the buffer named BUFFER-OR-NAME.

      BUFFER-OR-NAME must be a string or a buffer.

      If BUFFER-OR-NAME is a string and there is no buffer named
      BUFFER-OR-NAME, raise an error.

      If BUFFER-OR-NAME is a buffer, return BUFFER-OR-NAME.

      If BUFFER-OR-NAME is omitted or nil, return the current buffer.

      The return value from this function is always a buffer object, if
      it returns normally."
    #+END_SRC

    #+NAME: my--get-base-buffer-doc-string
    #+BEGIN_SRC emacs-lisp :exports none :tangle no
          "Return the base buffer of BUFFER-OR-NAME.

      If BUFFER-OR-NAME is not an indirect buffer, return the buffer
      corresponding to BUFFER-OR-NAME.

      If BUFFER-OR-NAME is a string and there is no buffer named
      BUFFER-OR-NAME, raise an error.

      If BUFFER-OR-NAME is omitted or nil, return the base buffer of
      the current buffer.

      The return value from this function is always a buffer object, if
      it returns normally."
    #+END_SRC

    #+NAME: my--base-buffer-is-p-doc-string
    #+BEGIN_SRC emacs-lisp :exports none :tangle no
          "Return non-nil if BASE is the base buffer of BUFFER.

      Both arguments must be actual buffers."
    #+END_SRC


    All four of the functions above are in scope only during
    compilation, making them useless outside of this file. They're
    really only here to make other definitions a little easier on the
    eyes. The documentation strings are included in the source, but
    excluded from export, in the interest of making this code block
    less noisy.

    Next, lets define some basic helper functions.

    - =my-buffer-list-with-base-buffer-of=

      Fetches all buffers that share their base buffer with the given
      one.

      #+HEADER: =my-buffer-list-with-base-buffer-of=
      #+NAME: lit-emacs-my-indirect-buffer-primitives-buffer-list-with-base
      #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
        (defun my-buffer-list-with-base-buffer-of (&optional buffer-or-name predicate)
          "Return all buffers that share their base buffer with BUFFER-OR-NAME.

        BUFFER-OR-NAME must be a string or a buffer.

        If BUFFER-OR-NAME is omitted of nil, `current-buffer' will be
        used instead.

        If BUFFER-OR-NAME is a buffer, this will always return a
        non-empty list.  BUFFER-OR-NAME is by definition one of the
        buffers with the same base buffer as BUFFER-OR-NAME.

        If BUFFER-OR-NAME is a string and a buffer by that name exists,
        the list of buffers with the same base buffer as that buffer is
        returned.

        If BUFFER-OR-NAME is a string that does not correspond to the
        name of an existing buffer, this function returns nil.

        In addition, an optional PREDICATE may be supplied to further
        filter the list of buffers returned.  Buffers for which the
        PREDICATE is non-nil will be omitted."
          (let ((buf (my--get-buffer buffer-or-name)))
            (when buf
              (let ((base-buf (my--get-base-buffer-of-buffer buf)))
                (seq-filter
                 #'(lambda(b)
                     (let ((other-buf (my--get-buffer b)))
                       (and (my--base-buffer-is-p base-buf other-buf)
                            (if predicate (apply predicate (list other-buf)) t))))
                 (buffer-list))))))
      #+END_SRC

      This function returns a list containing all buffers that share
      their base buffer with the given one. If called with no
      argument, it will list all buffers that share a base buffer with
      the current buffer.

      If no ~predicate~ is supplied, then the returned list is always
      non-empty: it /must/ contain the argument buffer.

      If the ~buffer-or-name~ argument is a string that does not match
      the name of an existing buffer, ~nil~ is returned.

    - =my-indirect-buffer-list-with-base-buffer-of=

      Fetches all /indirect/ buffers that share their base buffer with
      the given one.

      #+HEADER: =my-indirect-buffer-list-with-base-buffer-of=
      #+NAME: lit-emacs-my-indirect-buffer-primitives-indirect-buffers-of
      #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
        (defun my-indirect-buffer-list-with-base-buffer-of (&optional buffer-or-name predicate)
          "Return a list of all indirect buffers related to BUFFER-OR-NAME.

        BUFFER-OR-NAME must be a string or a buffer.

        If BUFFER-OR-NAME is an indirect buffer, all indirect buffers
        with the same base buffer as BUFFER-OR-NAME are returned.  This
        includes BUFFER-OR-NAME itself.

        If BUFFER-OR-NAME is not an indirect buffer, all indirect buffers
        with base buffer BUFFER-OR-NAME are returned.  This list will be
        nil, if there are no such indirect buffers.

        If BUFFER-OR-NAME is omitted or nil, the current buffer will be
        used instead.

        If BUFFER-OR-NAME is a string that is not the name of an existing
        buffer, return nil.

        In addition, an optional PREDICATE may be supplied to further
        filter the list of buffers returned.  Buffers for which the
        PREDICATE is non-nil will be omitted.

        Note: Keep in mind that there are two distinct ways for this
        function to return nil if BUFFER-OR-NAME is a string and
        PREDICATE is nil.  Do not use the return value of this function
        in if/where/unless clauses unless you're sure what that actually
        means."
          (let ((buf (my--get-buffer buffer-or-name)))
            ;; We could do something like this:
            ;;
            ;;(seq-remove #'(lambda (b) (eq b basebuf))
            ;;            (my-buffer-list-with-base-buffer-of basebuf))
            ;;
            ;; But why traverse the list twice?
            (when buf
              (let ((base-buf (my--get-base-buffer-of-buffer buf)))
                (my-buffer-list-with-base-buffer-of
                 buf
                 #'(lambda (b)
                       (let ((other-buf (my--get-buffer b)))
                         (and (not (eq base-buf other-buf))
                              (if predicate
                                  (apply predicate (list other-buf)) t)))))))))
      #+END_SRC

      This function returns a list containing all indirect buffers that
      share their base buffer with the given one. If called with no
      argument, it computes the list of indirect buffers that share a
      base buffer with the current buffer.

      If no ~predicate~ is supplied, then the resulting list will
      include the argument buffer if the argument buffer was an
      indirect buffer.

      As the documentation string notes, one potential point of
      confusion is that there are two distinct reasons why this
      function may have returned ~nil~, given a string argument and no
      ~predicate~.

      It could be that the string didn't match any existing buffer, or
      it could be that the buffer existed but that the list of
      indirect buffers based on it is ~nil~.

      The ambiguity can be avoided entirely if the argument is an
      actual buffer instead of just a name. Calling it with a ~nil~
      argument, or no argument, is also unambiguous.

      With a non-nil ~predicate~, all bets are off.

*** Creation

    Before we define a way to create indirect buffers (beyond the
    =emacs= built-ins), let's define some convenient hooks.

    #+HEADER: My Indirect Buffer Hooks
    #+NAME: lit-emacs-my-clone-indirect-buffer-hooks
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (defun my--living-clones-kill-buffer-query-fun ()
        "Display a warning prompt about indirect buffers of the current buffer.

      For use with `kill-buffer-query-functions'.  Should not need to
      be called directly.  Nor should it need to be added or removed
      manually."
        (let ((buf (current-buffer)))
          (or
           (null (my-indirect-buffer-list-with-base-buffer-of buf))
           (y-or-n-p
            (concat "There appear to be live indirect buffers using"
                    (format " buffer %s as a base. Really kill it?"
                            buf))))))

      (defun my--clean-up-indirect-buffer-clone-hooks-hook()
        "Used in `my-clone-indirect-buffer'.

      Locally deletes itself from `clone-indirect-buffer-hook', and
      deletes `my--living-clones-kill-buffer-query-fun' from
      `kill-buffer-query-functions' when run.

      Should not need to be called or added/removed manually."
        (remove-hook 'kill-buffer-query-functions
                     #'my--living-clones-kill-buffer-query-fun
                     t)
        (remove-hook 'clone-indirect-buffer-hook
                     #'my--clean-up-indirect-buffer-clone-hooks-hook ;(selfCleanUpHook)
                     t))
    #+END_SRC

    The first hook adds an extra prompt to the affected buffer if that
    buffer has any indirect buffers when the user tries to kill it.

    The second hook deletes the first hook when present in a newly
    cloned indirect buffer. And it deletes itself: note the
    self-referentiality of line [[(selfCleanUpHook)]].

    Armed with those hooks we can define =my-clone-indirect-buffer=.

    #+HEADER: =my-clone-indirect-buffer=
    #+NAME: lit-emacs-my-clone-indirect-buffer
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (defun my-clone-indirect-buffer (newname display &optional norecord)
        "Clone the current buffer and then display the clone in the current window.

      The new indirect buffer will be named NEWNAME, or will be
      generated by `clone-indirect-buffer' if nil was supplied.  When
      called interactively with a prefix argument, prompt for NEWNAME
      using the minibuffer.  Without a prefix argument, behave as if
      NEWNAME was nil.

      If DISPLAY is 'switch, he newly created buffer is displayed in
      the current window using `switch-to-buffer'.  This is always the
      case when called interactively.  Any other non-nil value of
      DISPLAY will display the buffer using `pop-to-buffer'.

      If NORECORD is non-nil, do not put this at the front of the list of
      recently selected buffers.

      The new buffer is returned.

      This function mimics `clone-indirect-buffer', but with slightly
      different DISPLAY related behaviour.  In addition it adds
      `my--living-clones-kill-buffer-query-fun' and
      `my--clean-up-indirect-buffer-clone-hooks-hook' to the
      `kill-buffer-query-functions' and `clone-indirect-buffer-hook'
      hook lists."
        (interactive
         ;; logic borrowed from clone-indirect-buffer           ;(cloneBufferArgParse)
         (progn
           (if (get major-mode 'no-clone-indirect)
               (error "Cannot indirectly clone a buffer in %s mode" mode-name))
           (list
            (when current-prefix-arg
              (read-buffer "Name of new indirect buffer: " (current-buffer)))
            'switch)))
        (with-current-buffer (my--get-base-buffer)          ;(myCloneIndInstallHooks)
          (add-hook 'kill-buffer-query-functions
                    #'my--living-clones-kill-buffer-query-fun
                    nil
                    t)
          (add-hook 'clone-indirect-buffer-hook
                    #'my--clean-up-indirect-buffer-clone-hooks-hook
                    nil
                    t))
        (let ((newbuf (clone-indirect-buffer newname nil norecord)))
          (cond
           ((eq display 'switch) (switch-to-buffer newbuf))
           (display (pop-to-buffer newbuf)))
          ;; Otherwise -> do nothing
          newbuf))
    #+END_SRC

    Some interactive argument parsing logic from
    =clone-indirect-buffer= is duplicated [[(cloneBufferArgParse)][here]], but I see no great way
    to avoid doing this. We really /do/ need to check if the current
    major mode supports cloning before we do anything else.


    Lastly, lets add advice to =clone-indirect-buffer= and
    =clone-indirect-buffer-other-window= to setup the same hooks used
    in the function above.

    #+NAME: lit-emacs-clone-indirect-buffer-advice
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (defun my--before-clone-indirect-advice(&rest ignored)
        "Advice to run before `clone-indirect-buffer'.

      Will also affect `clone-indirect-buffer-other-window', since it
      calls `clone-indirect-buffer'.

      All arguments are IGNORED.

      Adds `my--living-clones-kill-buffer-query-fun' and
      `my--clean-up-indirect-buffer-clone-hooks-hook' to the
      `kill-buffer-query-functions' and `clone-indirect-buffer-hook'
      hook lists of the base buffer of the current buffer."
        (with-current-buffer (my--get-base-buffer)
          (add-hook 'kill-buffer-query-functions
                    #'my--living-clones-kill-buffer-query-fun
                    nil
                    t)
          (add-hook 'clone-indirect-buffer-hook
                    #'my--clean-up-indirect-buffer-clone-hooks-hook
                    nil
                    t)))
      ;; Add the advice.
      (advice-add 'clone-indirect-buffer
                  :before
                  #'my--before-clone-indirect-advice)
    #+END_SRC

    This renders [[(myCloneIndInstallHooks)][the corresponding block]] in =my-clone-indirect-buffer=
    redundant, but it's nice to have it there too, in case the advice
    needs to be switched off for whatever reason.

*** Destruction

    We need a convenient way to kill a group of clone
    buffers. The way to do that is to kill the original one. To
    facilitate that we define =my-kill-base-buffer=, which finds the
    base buffer of the given buffer and calls =kill-buffer= on it.

    #+HEADER: =my-kill-base-buffer=
    #+NAME: lit-emacs-my-kill-base-buffer
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (defun my-kill-base-buffer (&optional buffer-or-name)
        "Kill the base buffer of BUFFER-OR-NAME.

      If BUFFER-OR-NAME was omitted or is nil, the base buffer of the
      current buffer is targeted instead.  See `buffer-base-buffer' and
      `kill-buffer' for details on what this means.

      If called interactively with a prefix argument, prompt for a
      buffer to target using the minibuffer.

      Returns t if a buffer was killed, nil otherwise."
        (interactive
         (list
          (when current-prefix-arg
            (read-buffer "Name of buffer to target: " (current-buffer) t))))
        (kill-buffer (my--get-base-buffer buffer-or-name)))
    #+END_SRC

    Obviously, this is reduces to just =kill-buffer= when the argument
    is not an indirect buffer. For an indirect buffer though, this
    really will kill it, its base buffer, and its siblings.


    Sometimes it's useful to be able to kill off indirect clones but not the base buffer.

    #+HEADER: =my-kill-indirect-buffers-of=
    #+NAME: lit-emace-my-kill-indirect-buffers-of
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (defun my-kill-indirect-buffers-of (&optional buffer-or-name
                                                    switch-to-base
                                                    echo-kill-count)
        "Kill all indirect buffers with the same base buffer as BUFFER-OR-NAME.

      BUFFER-OR-NAME must be a buffer, a string or nil.

      If BUFFER-OR-NAME is nil, the current buffer is used instead.  If
      called with interactively with a prefix argument, prompt the user
      for a buffer to target instead of the current buffer.

      If BUFFER-OR-NAME is a string that is not the name of an existing
      buffer, do nothing and return nil.

      If SWITCH-TO-BASE is non-nil, switch to the base buffer of
      BUFFER-OR-NAME using `switch-to-buffer' before killing the
      indirect buffers.  This is always done when called interactively.

      If ECHO-KILL-COUNT is non-nil, show a message about the number of
      buffers killed.  This is always done when called interactively.

      The number of buffers killed is returned, or nil if
      BUFFER-OR-NAME does not exist."
        (interactive
         (list
          (when current-prefix-arg
            (read-buffer "Name of buffer to target: " (current-buffer) t))
          t
          t))
        (let* ((basebuf (my--get-base-buffer buffer-or-name))
               (targetlist (my-indirect-buffer-list-with-base-buffer-of basebuf))
               (numtargets (length targetlist)))
          (if (not basebuf) nil
            (when switch-to-base (switch-to-buffer basebuf nil t))
            (let ((numkilled (seq-reduce
                              #'(lambda(acc val)
                                  (if (kill-buffer val)
                                      (+ 1 acc)
                                    acc))
                              targetlist 0)))
              (when echo-kill-count
                (message "Killed %d indirect buffers (out of %d)"
                         numkilled
                         numtargets))
              numkilled))))
    #+END_SRC


*** Management

**** Switching

     In order to make switching between indirect buffers easier, we
     define a function specifically for that.

     #+NAME: lit-emacs-my-swithc-to-buffer-with-base-buffer-of
     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
       (defun my-switch-to-buffer-with-base-buffer-of (&optional buffer)
         "Prompt for a buffer sharing its base buffer with BUFFER and switch to it.

       If BUFFER is omitted or nil, use the current buffer instead.

       With a prefix argument, prompt for the base buffer to use.

       This function is intended exclusively for interactive use."
         (declare
          (interactive-only
           "Please use my-buffer-list-with-base-buffer-of directly instead"))
         (interactive
          (list (when current-prefix-arg
                  (read-buffer "Base buffer: " (current-buffer) t))))
         (let* ((buf (or (my--get-buffer buffer) (current-buffer)))
                (buflist
                 (my-buffer-list-with-base-buffer-of
                  buf
                  #'(lambda (b)  (not (eq b buf))))))
           ;; Error if the chosen buffer disappeared while we were selecting
           ;; it.
           (switch-to-buffer                                         ;(compReadBuffer)
            (my--get-buffer-or-err
            (completing-read "Switch to sibling buffer: "
                             (seq-map #'buffer-name buflist) nil t)))))
     #+END_SRC

     This is a somewhat primitive approach using completing read. But
     that plays nice with =helm= without having to make a new source.

     One thing to note here is line [[(compReadBuffer)]] where a string
     rather than a buffer is actually passed to
     =switch-to-buffer=. This irks me a little, but there's not much to
     be done. I could build an alist connecting buffers and buffer
     names, prompt for one of the keys and then fetch the actual buffer
     from alist. But that wouldn't do a whole lot here. There's no
     danger of the buffer not existing that wouldn't also be present if
     I went the alist route.

**** Making a view unique

     If I have the same buffer open in multiple windows in the same
     frame, I'd like to be able to make the currently selected one
     "unique". I mean by this, that I'd like to swap the current one
     for a preexisting indirect clone, or create one if one does not
     exist.

     #+NAME: lit-emacs-make-current-view-unique
     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
       (defun my-make-current-view-unique ()
         "Make the buffer in the current window unique in the `selected-frame'.

       For the purposes of this command, a buffer is unique in a frame
       if there is only one visible window displaying it.  To achieve
       its goal, this function will, if needed, try to find a not
       currently visible buffer with the same base buffer as the current
       buffer and switch to that one.  If multiple such buffers are
       found, the user is queried for which one to use.  If no such
       buffers exist, create a new one using
       `my-clone-indirect-buffer'.

       This function is intended for interactive use only.  If you want
       something like this for non-interactive use, you're going to have
       to call `my-buffer-list-with-base-buffer-of' and
       `my-clone-indirect-buffer' yourself."
         (declare
          (interactive-only
           (concat
            "Please use my-clone-indirect-buffer and "
            "my-buffer-list-with-base-buffer-of directly instead")))
         (interactive)
         (let* ((this-frame (selected-frame))
                (this-buf   (my--get-buffer))
                (windows-with-buf
                 (get-buffer-window-list this-buf nil this-frame)))
           (if (< 1 (length windows-with-buf))
             (let ((candidates
                    (my-buffer-list-with-base-buffer-of
                     this-buf
                     #'(lambda (b)
                         (and (not (eq this-buf b))
                              (= 0 (length
                                    (get-buffer-window-list b nil this-frame))))))))
               (cond
                ((null candidates)
                 (message "Cloning buffer %s.." (buffer-name this-buf))
                 (my-clone-indirect-buffer nil 'switch t))
                ((= 1 (length candidates))
                 (message "Switching to sole candidate %s.."
                          (buffer-name (car candidates)))
                 (switch-to-buffer (car candidates) t t))
                (t
                 (let ((candidate
                        ;; Raise error if the candidate buffer disappeared
                        ;; while we were selecting it.
                        (my--get-buffer-or-err
                         (completing-read
                          "Select a non-visible sibling buffer: "
                          (seq-map #'buffer-name candidates) nil t))))
                   (message "Switching to selected candidate %s.." candidate)
                   (switch-to-buffer candidate t t)))))
             (message
              "Buffer %s is already unique in frame.." (buffer-name this-buf)))))
     #+END_SRC

*** Keybindings: Indirect Buffers               :actual_keybind_loc:noexport:

    #+BEGIN_SRC emacs-lisp
    <<lit-emacs-indirect-buffer-key-binds>>
    #+END_SRC

** Emacs Server

   Should be booted up if it isn't already. Unless we're in
   =noninteractive= mode.

   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     ;; Start the server after init, unless we're in batch mode or
     ;; something.
     (use-package server
       :unless  noninteractive
       :no-require t
       :hook (after-init . server-start))
   #+END_SRC

** =pdf-tools=

   Not exactly basic, but I'd like to get this out of the way early,
   and I'm not sure where else to put it.

   Note that when this package is updated, the pdf-tools backends
   will need to be rebuilt. This rebuilding process will cause a
   prompt to appear in emacs, which means it may be unwise to start
   emacs as a daemon immediately after updating that package. Since
   you might not see the prompt.

   #+NAME: lit-emacs-init-pdf-tools
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     (use-package pdf-occur
       :defer t
       :ensure pdf-tools
       :after pdf-tools
       :commands (pdf-occur-global-minor-mode))
     (use-package pdf-tools
       :defer t
       :ensure t
       ;; Trick copied from the use-package README. This will load
       ;; pdf-tools just in time.
       :commands (pdf-tools-install)
       :magic ("%PDF" . pdf-view-mode)
       :config (pdf-tools-install))
   #+END_SRC

** Misc Look And Feel

*** =powerline= and =encourage=

    A pair of straight forward ui packages.

    #+NAME: lit-emacs-init-powerline-setup
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      ;; These don't do anything in non-interactive mode.
      (use-package powerline
        :defer t
        :ensure t
        :functions (my-powerline-vc)
        :config
      <<my-powerline-vc-advice>>
        :hook (after-init . powerline-default-theme))
      ;; No real point in deferring this; it's tiny.
      (use-package encourage-mode
        :ensure t
        :diminish)
    #+END_SRC

    WRITTEN [2019-05-19 sön]:

    =powerline= by default checks whether ~(buffer-file-name
    (current-buffer))~ is ~nil~, as part of the logic to determine
    whether to show vcs information. This doesn't work particularly
    well in indirect buffers, where that value is always nil. Thus,
    I'm forced to override it with my modified version defined here.

    #+NAME: lit-init-my-powerline-vc-advice
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :tangle no :noweb-ref my-powerline-vc-advice
      ;; Identical to powerline-vc save for using `my--get-base-buffer'
      ;; instead of `current-buffer'.
      (defpowerline my-powerline-vc
        (when (and (buffer-file-name (my--get-base-buffer)) vc-mode)
          (if (and window-system (not powerline-gui-use-vcs-glyph))
              (format-mode-line '(vc-mode vc-mode))
            (format " %s%s"
                    (char-to-string #xe0a0)
                    (format-mode-line '(vc-mode vc-mode))))))
      (init-say "Overriding the definition of powerline-vc.." "powerline")
      (advice-add 'powerline-vc :override #'my-powerline-vc)
    #+END_SRC


*** The =delight= package

    A fancier version of =dimninish=, pretty much.

    #+NAME: lit-init-general-delight
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (use-package delight
        :ensure t)
    #+END_SRC
*** Additional =delight= / =dimninish= invocations

    Some =diminish= calls that need to happen, but which don't really
    belong anywhere.

    #+NAME: lit-init-general-additional-diminish
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (diminish 'eldoc-mode)
    #+END_SRC


** Other misc packages

   Packages I need here for some reason or another, but which don't
   obviously belong in any particular category.

   - =htmlize=

     Required by =org= export functions, to export highlighted code
     blocks to html properly.

     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
       (use-package htmlize
         :defer t
         :ensure t)
     #+END_SRC


* Project Management

  Version control, project navigation, etc.

** =magit=

   The cleanest git interface I've yet to encounter.

   #+NAME: lit-emacs-init-magit-setup
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     (use-package magit
       :bind ("H-g" . magit-status)
       :ensure t
       :config
       (use-package magit-files
         :commands (global-magit-file-mode)
         :ensure magit
         :config
         (global-magit-file-mode)))
   #+END_SRC

** =projectile=

   The project management package.

   #+NAME: lit-emacs-init-projectile-setup
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     (use-package projectile
       :defer 5 ;; Load unconditionally after 5 seconds
       ;; Reduce mode line impact
       :delight '(:eval (concat " [" (projectile-project-name) "]"))
       :ensure t
       :commands (projectile-mode)
       :config (projectile-mode +1)
       :bind-keymap ("H-p" . projectile-command-map))               ;(projectileKeymap)
   #+END_SRC

   I'm defining how to access the ~projectile-mode-map~ [[(projectileKeymap)][here]] rather
   than any specific command, as that's the recommended way to set
   this up.




* Editing Functionality

  Packages related to code or text editing.

** General Editing Functionality


*** =company=

    Completion setup is fairly simplistic:

    #+NAME: lit-emacs-init-company-setup
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (use-package company
        :defer 2 ;; Load unconditionally after 2 sec
        :diminish company-mode
        :ensure t
        :commands
        (company-abort
         company-complete-number
         global-company-mode)
        :bind (:map global-map
                    ("C-:" . company-complete))                ;(companyCompleteBind)
        :config
        ;; Taken from jweigley's dot-emacs repo.                        ;(jwRepoNote)

        ;; See http://oremacs.com/2017/12/27/company-numbers/
        (defun ora-company-number ()
          "Forward to `company-complete-number'.
        Unless the number is potentially part of the candidate.
        In that case, insert the number."
          (interactive)
          (let* ((k (this-command-keys))
                 (re (concat "^" company-prefix k)))
            (if (cl-find-if (lambda (s) (string-match re s))
                            company-candidates)
                (self-insert-command 1)
              (company-complete-number (string-to-number k)))))

        (let ((map company-active-map))
          (mapc
           (lambda (x)
             (define-key map (format "%d" x) 'ora-company-number))
           (number-sequence 0 9))
          (define-key map " " (lambda ()
                                (interactive)
                                (company-abort)
                                (self-insert-command 1))))
        (global-company-mode 1))
    #+END_SRC

    Some notes:

    - [[(companyCompleteBind)][This]] is not the only place where I make bindings
      related to the ~company-mode-map~.

    - All of the [[(jwRepoNote)][config code]] above was taken from John Weigley's
      [[https://github.com/jwiegley/dot-emacs][dot-emacs]] repository. From his =init.el= file specifically.

    - Which modes are affected by the =global-company-mode= is
      determined by a =custom= variable.


**** Additional =company= backends

     #+NAME: lite-emacs-init-company-extra-backends-default
     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
       (use-package company-cabal
         :after (company)
         :ensure t
         :defer t)
       (use-package company-ghci
         :after (company)
         :ensure t
         :defer t)
       (use-package company-math
         :after (company)
         :ensure t
         :defer t)
       (use-package company-glsl
         :after (company)
         :ensure t
         :defer t)
       (use-package company-c-headers
         :after (company)
         :ensure t
         :defer t)
     #+END_SRC

     These above need to be activated by adding the relevant commands
     to =company-backends=. This is best done via the =customize=
     interface.


**** =company-quickhelp=

     This package displays help for completions, when completions are
     hovered.

     #+NAME: lit-emacs-init-company-quickhelp-setup
     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
       (use-package company-quickhelp
         :after (company)
         :ensure t
         :defer t
         ;; Load this in prog modes.
         :init
         (defun my--company-quickhelp-hook()
           "Activate `company-quickhelp-mode' in `prog-mode'"
           (company-quickhelp-mode))
         :hook (prog-mode . my--company-quickhelp-hook))
     #+END_SRC


*** =multiple-cursors=

    Having had a taste of multiple cursors in vs code, I now feel I
    need it here too. Luckily there's a package for that.

    #+NAME: lit-emacs-init-multiple-cursor-setup
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (use-package multiple-cursors
        :defer t
        :ensure t
        :bind (:map global-map
                    ;; Short Keybindings
                    ("C->" . mc/mark-next-like-this)
                    ("C-<" . mc/mark-previous-like-this)
                    ("C-M->" . mc/mark-next-like-this-symbol)
                    ("C-M-<" . mc/mark-previous-like-this-symbol)
                    ("M->" . mc/mark-next-like-this-word)
                    ("M-<" . mc/mark-previous-like-this-word)
                    ;; Longer Bidings
                    ;; Lines
                    ("C-H-l l" . mc/edit-lines)
                    ("C-H-l C-a" . mc/edit-beginnings-of-lines)
                    ("C-H-l C-e" . mc/edit-ends-of-lines)
                    ;; Next/Previous like selection
                    ("C-H-n" . mc/mark-next-like-this)
                    ("C-H-M-n" . mc/skip-to-next-like-this)
                    ("C-H-p" . mc/mark-previous-like-this)
                    ("C-H-M-p" . mc/skip-to-previous-like-this)
                    ;; Next/Previous word/symbol
                    ("H-M-n" . mc/mark-next-like-this-symbol)
                    ("H-M-p" . mc/mark-previous-like-this-symbol)
                    ("H-M-f" . mc/mark-next-like-this-word)
                    ("H-M-b" . mc/mark-previous-like-this-word)
                    ;; All like this
                    ("C-H-a a" . mc/mark-all-dwim)
                    ("C-H-a g" . mc/mark-all-like-this)
                    ("C-H-a f" . mc/mark-all-like-this-in-defun)
                    ("H-M-w g" . mc/mark-all-words-like-this)
                    ("H-M-w f" . mc/mark-all-words-like-this-in-defun)
                    ("H-M-s g" . mc/mark-all-symbols-like-this)
                    ("H-M-s f" . mc/mark-all-symbols-like-this-in-defun)))
    #+END_SRC


*** =pcomplete=

    Set up =pcomplete= as a =completion-at-point= function. =org=
    wants this, plus it gives me a neat way to add basic custom
    completion for certain basic things like =haskell= pragmas and the
    like. In general =pcomplete= can be useful to set up when the set
    of possible things to complete is small and the set of completions
    is small. It's sort of like the completion framework in
    =bash=. Dumb, but straight-forward.

    Note: This is very much /not/ a replacement for "real" completion
    facilities. I think more of it as being a useful way to add basic
    custom completion. Not totally unlike =abbrev=, but slightly
    cleverer.

    #+NAME: lit-emacs-init-pcomplete-setup
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"

      (use-package pcomplete
        :defer t
        :no-require t ; built in, I believe
        :commands (pcomplete
                   pcomplete-completions-at-point
                   pcomplete--here
                   pcomplete-entries)
        :bind (:map global-map
                    ("H-! c <tab>" . pcomplete))
        ;; Tying the load to company-mode for now.
        :init
        (defun my-setup-pcomplete-capf-hook()
          (add-hook 'completion-at-point-functions #'pcomplete-completions-at-point))
        :config
        (unless (or (get 'pcomplete-default-completion-function 'saved-value)
                    (get 'pcomplete-default-completion-function 'themed-value))
          (mapc (apply-partially #'message "[init-general|pcomplete] %s")
                '(
      "pcomplete-default-completion-function appears to be set to it's default value!"
      "This is not advisable, as it won't compile and evaluate properly."
      "Attempting to set alternate value.."))
          (customize-set-variable
           'pcomplete-default-completion-function
           #'(lambda() (pcomplete-here (pcomplete-entries)))    ;(pcmp:defaultCmpDef)
           (concat "[init-general] Auto-replaced, to avoid "
                   "errors if `pcomplete.el' was loaded in "
                   "compiled form. Equivalent to the "
                   "original definition given in "
                   "`pcomplete.el'.")))
        (unless (or (get 'pcomplete-command-completion-function 'saved-value)
                    (get 'pcomplete-command-completion-function 'themed-value))
          (mapc (apply-partially #'message "[init-general|pcomplete] %s")
                '(
      "pcomplete-command-completion-function appears to be set to it's default value!"
      "This is not advisable, as it won't compile and evaluate properly."
      "Attempting to set alternate value.."))
          (customize-set-variable
           'pcomplete-command-completion-function
           #'(lambda () (pcomplete-here (pcomplete-executables)))
           (concat "[init-general] Auto-replaced, to avoid "
                   "errors if `pcomplete.el' was loaded in "
                   "compiled form. Equivalent to the "
                   "original definition given in "
                   "`pcomplete.el'.")))
        :hook (company-mode . my-setup-pcomplete-capf-hook))

    #+END_SRC



    *IMPORTANT NOTE*: Do /not/ use the default value for
    =pcomplete-default-completion-functions=, as it will misbehave and
    throw "invalid function" errors both when invoked using
    =pcomplete= and when used as a completion at point back-end for
    =company=. The [[(pcmp:defaultCmpDef)][lambda expression]] I substitute it with is precisely
    the same as the definition given in =pcomplete.el= except quoted
    in a slightly different way[fn:pcomp], which makes the
    byte-compiler do the right thing.

    If anyone reading this actually cares about the details of what
    this is fixing: the default value that =customize= ends up with if
    =pcomplete.el= is byte-compiled is the same lambda expression I've
    used in the code above, but with /only the lambda part
    byte-compiled!/ Meaning the =pcomplete-here= macro doesn't get
    compiled out of existence, which then leads to "invalid function
    pcomplete-here" errors when you try to invoke completion using
    =pcomplete=. If the expression is quoted as ='(lambda () ...)=,
    the byte compiler won't touch it which allows =emacs= to recognise
    that the expression inside the lambda is a macro and /not/ a
    function. Alternatively, if the expression is quoted as =#'(lambda
    () ...)=, the byte-compiler will instead compile both it /and/ its
    body, thus annihilating the macro completely and leaving us with a
    byte-compiled lambda wrapping some function calls. Either approach
    will solve the issue.

[fn:pcomp] or arguably the same way, but at a different time / in a
    different context. The order of operations and evaluation
    semantics involved in quoting/anti-quoting/macro-expansion/etc
    during compilation and their consequences for the meaning of an
    expression at run-time are subtle and treacherous.

*** =avy= editing/navigation

    #+NAME: lit-emacs-init-avy-prog-mode-setup
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      ;; Fast navigation and 'zap'-ing to specific nearby chars, with a
      ;; keyboard based "disambiguation" mode.
      (use-package avy                                                     ;(avyMode)
        :defer t
        :ensure t
        :commands (avy-setup-default)
        :config (avy-setup-default)
        :bind (("C-'" . avy-goto-char-2)
               ("C-*" . avy-goto-subword-1)
               ("H-'" . avy-goto-char-in-line)))
      (use-package avy-zap
        :defer t
        :ensure t
        :bind (("M-z" . avy-zap-up-to-char)
               ("M-Z" . avy-zap-to-char)))
    #+END_SRC


    For info on what [[(avyMode)][=avy=]] does exactly, see the built-in
    documentation or https://github.com/abo-abo/avy.



*** =flyspell= and =flycheck=

    #+NAME: lit-emacs-init-flyspell-flycheck-setup
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      ;; flyspell
      (use-package flyspell
        :diminish flyspell-prog-mode                            ;(flyspellProgMode)
        :diminish flyspell-mode
        :ensure t
        :config
        ;; Delete some default bindings, to stop flyspell from eating up
        ;; keyboard real-estate that other modes (like org) could make much
        ;; better use of.  This needs to happen during config, since if I
        ;; modify the map before it's loaded, the modification won't stick.
        (unbind-key "C-c $" flyspell-mode-map)
        (unbind-key "C-M-i" flyspell-mode-map)
        ;; helm-flyspell overwrites this one anyway.
        (unbind-key "C-;" flyspell-mode-map)
        :hook ((prog-mode . flyspell-prog-mode)
               (text-mode . flyspell-mode)))

      ;; flycheck
      (use-package flycheck
        :ensure t
        :hook ((prog-mode     . flycheck-mode)))
               ;(flycheck-mode . flycheck-cask-setup)))

      ;; pos-tip support for displaying flycheck errors
      (use-package pos-tip
        :ensure t
        :defer t)
      (use-package flycheck-pos-tip
        :diminish
        :ensure t
        :after (flycheck)
        :hook (flycheck-mode . flycheck-pos-tip-mode))

    #+END_SRC

    Note that ~flyspell-mode~ for /programming/ mode is a [[(flyspellProgMode)][different]]
    mode than the /text/ oriented one.



** Code Editing Functionality

   Firstly some general stuff:

   #+NAME: lit-emacs-init-delims-wc-etc-prog-mode-setup
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     (use-package rainbow-delimiters
       :ensure t
       :hook (prog-mode . rainbow-delimiters-mode)
       :diminish)

     (use-package smartparens
       :ensure t
       :hook (prog-mode . smartparens-mode)
       :diminish)

     (use-package column-enforce-mode
       :ensure t
       :hook (prog-mode markdown-mode)
       :diminish)

     (use-package highlight-indentation
       :ensure t
       :hook ((prog-mode . highlight-indentation-mode)
              (prog-mode . highlight-indentation-current-column-mode)
              (org-mode  . highlight-indentation-mode))
       :diminish highlight-indentation-mode
       :diminish highlight-indentation-current-column-mode)

     (use-package whitespace-cleanup-mode
       :ensure t
       :hook (prog-mode org-mode)
       :diminish)
   #+END_SRC

   Delimiter and whitespace handling. Not all that exiting. And
   column-enforce also applies to =text-mode=.

*** Lang Major Modes

    Initialisation for specific programming language major modes. Many
    don't need anything specific, but a handful do.

    - Haskell

      Due to a key map conflict with ~haskell-interactive-mode~, I
      need to unset some bindings when ~haskell-mode~ loads.

      #+NAME: lit-emacs-init-haskell-mode
      #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
        (use-package haskell-mode
          :ensure t
          :defer t
          :config
          (mapc (lambda (x) (define-key haskell-mode-map (kbd x) nil))
                '("C-c C-i"
                  "C-c C-l"
                  "C-c C-t"
                  "C-c C-b"
                  "C-c C-v")))

        (use-package hlint-refactor
          :ensure t
          :defer t)

        (use-package flycheck-haskell
          :after (flycheck haskell-mode)
          :ensure t
          :hook (haskell-mode . flycheck-haskell-setup))

      #+END_SRC

    - Idris

      #+NAME: lit-emacs-init-idris-mode
      #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
        (use-package idris-mode
          :ensure t
          :defer t)

        (use-package helm-idris
          :ensure t
          :defer t
          :after (helm idris-mode))
      #+END_SRC

    - MATLAB

      Important note: The /package/ is called ~matlab-mode~, but the
      /library and feature/ is called ~matlab~. Thus one must load the
      the ~matlab~ library, but /ensure/ the ~matlab-mode~
      package. Confusing, but that's life.

      #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
        (use-package matlab
          :ensure matlab-mode
          :defer t)
      #+END_SRC

** Text Editing Functionality

   Not much text specific going on in this file. Just =pandoc=,
   basically.

   #+NAME: lit-emacs-init-pandoc-mode-setup
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     (use-package markdown-mode
       :ensure t
       :config (use-package pandoc-mode
                 :ensure t
                 :diminish
                 :commands pandoc-load-default-settings
                 :hook markdown-mode
                 :config (pandoc-load-default-settings)))
   #+END_SRC


** Line Numbers
*** Emacs version

    Native line numbering support was added in =emacs= 26.1, thus we
    only want the =linum= related code in this file if we're on a
    version less than that.


    #+NAME: lit-emacs-init-emacs-version-guard
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :tangle yes :noweb yes
      ;; Use linum if emacs doesn't have line-numbers yet.
      (eval-when-compile
        (defmacro lit-init-linum-mk-body()
          (if (version<  emacs-version "26.1")
              `(progn
                <<linum-pre-26.1>>                                       ;(preEmacs26)
                )
            `(progn
               <<line-numbers-post-26.1>>))))                          ;(postEmacs26)
      (lit-init-linum-mk-body)

    #+END_SRC

    For the body of [[(preEmacs26)][line (preEmacs26)]] see section [[The Solution][The Solution]]
    below. The body of [[(postEmacs26)][line (postEmacs26)]] is in section [[*Display Line
    Numbers Mode]] below.

*** Display Line Numbers Mode                                     :post_v_26:
    :PROPERTIES:
    :header-args: :tangle no
    :END:


    Activate =global-display-line-numbers=.

    #+NAME: lit-emacs-init-display-line-numbers-mode
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :noweb-ref line-numbers-post-26.1 :noweb yes
      (use-package display-line-numbers-mode
        :no-require t ; This is a built-in.
        :demand t     ; Don't wait, it's a built-in.
        :commands (global-display-line-numbers-mode)
        ;; Makes the byte-compiler happy
        :functions (my-display-line-numbers--turn-on-advice)
        :preface
      <<display-line-numbers-new-defcustoms>>
        :config
      <<display-line-numbers--turn-on-advice>>
      <<line-numbers-toggle-widen>>
        (global-display-line-numbers-mode 1)
        :bind (:map global-map
                    ("H-n l" . my-toggle-line-numbers-widen)))
    #+END_SRC


**** Global mode customization

     WRITTEN [2019-05-11 lör 14:11]

     This was more or less copied from section [[*The Solution]] below.

     #+NAME: lit-emacs-init-global-display-line-number-defcustoms
     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :noweb-ref display-line-numbers-new-defcustoms
       (defcustom global-display-line-numbers-mode-modes-blacklist
         '(eshell-mode
           wl-summary-mode
           compilation-mode
           org-mode
           text-mode
           dired-mode
           doc-view-mode
           pdf-view-mode
           haskell-interactive-mode)
         "List of major modes where `global-display-line-numbers-mode'
       shouldn't apply."
         :type '(repeat (sexp :tag "Major mode"))
         :tag "Global Display Line Numbers Mode Major Mode Blacklist"
         :group 'display-line-numbers-mode)

       (defcustom global-display-line-number-mode-ignore-starred-buffers 't
         "If non-nil, `global-display-line-numbers-mode' will ignore
       starred buffers such as *Gnu Emacs*."
         :type 'boolean
         :tag "Global Display Line Numbers Mode Ignore Starred Buffers"
         :group 'display-line-numbers-mode)
     #+END_SRC

     The advice for the =turn-on= function in this case is slightly
     different. See line [[(turnOnAdviceCondition)]], in the block below.

     Main reason for the difference is because I bothered to spend some
     time actually trying to make sense of the possible ~where~
     arguments to =advice-add=.

     #+NAME: lit-emacs-init-global-display-line-number-turn-on-advice
     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :noweb-ref display-line-numbers--turn-on-advice
       (defun my-display-line-numbers--turn-on-advice ()
         "Advice for `display-line-numbers--turn-on'.

       If this function returns nil, `display-line-numbers--turn-on'
       should not be called.

       Adds extra checks based on
       `global-display-line-numbers-mode-modes-blacklist' and
       `global-display-line-numbers-mode-ignore-starred-buffers'."

         (or (member major-mode
                     global-display-line-numbers-mode-modes-blacklist)
             (and global-display-line-number-mode-ignore-starred-buffers
                  (string-match "*" (buffer-name)))))

       (init-say "Adding advice to display-line-numbers--turn-on.." "display-line-numbers")
       (advice-add 'display-line-numbers--turn-on
                   :before-until                              ;(turnOnAdviceCondition)
                   #'my-display-line-numbers--turn-on-advice)
     #+END_SRC




**** Numbers And Narrowing

     WRITTEN: [2019-08-10 lör]

     The built-in =display-line-numbers-mode= of =emacs= version 26.1
     supports numbering lines in a narrowed buffer in one of two
     modes. Either it can acknowledge the narrowing and display numbers
     relative to the currently visible part of the buffer, or it can
     ignore the narrowing and display the actual (widened) line number.

     I normally want the former behaviour, because it makes more sense
     if one views a narrowed buffer to number only those lines that are
     actually accessible. /But/, when trying to track down sources of
     error messages from external programs (such as compilers, for
     instance) one frequently needs the widened line number, since the
     external program is likely unaware of narrowing.

     Thus a toggle is needed:


     #+NAME: lit-emacs-init-display-line-numbers-mode-toggle-widen
     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :noweb-ref line-numbers-toggle-widen :noweb no
       (defun my-toggle-line-numbers-widen()
         "Toggle whether to display narrowed or true line numbers when narrowed."
         (interactive)
         ;; No further checks are needed here, since this variable can only
         ;; be nil or non-nil, and becomes buffer local when modified.
         (setq display-line-numbers-widen
               (not display-line-numbers-widen)))
     #+END_SRC


*** Linum                                                          :pre_v_26:
    :PROPERTIES:
    :header-args: :tangle no
    :END:


    Line numbering minor mode. See the relevant emacs documentation for details.

**** The Problem

     WRITTEN: [2018-10-17 ons 12:47]

     I'd like to use ~global-linum-mode~, but it interacts badly with a
     number of different other modes and buffers:

     - Interactive buffers, such as repl buffers and compilation buffers
       may end up becoming exceedingly long. This eventually causes
       =linum= to start to consume unacceptable amounts of system
       resources.

     - Certain other "starred" buffers such as =*Messages*= also exhibit
       this problem.

     - =linum= combined with =pdf-view-mode= exhibits similar problems,
       albeit for different reasons. I forget what those reasons are
       exactly; it's been a while since I looked this up. In any case
       trying to add line numbers to a pdf buffer is a) useless, and b)
       causes *massive* slowdowns.

     And in addition, there are a few modes where it behaves just fine,
     but where I'd like it turned off anyway.

     Sadly there is no built in way to blacklist or exclude certain
     modes from being affected by ~global-linum-mode~. And I don't want
     to have to whitelist every single mode that /does/ work with
     ~global-linum-mode~. Which is also not a thing that's supported in
     the =linum= customize category.

**** The Solution

     WRITTEN: [2018-10-17 ons 12:51]

     Since neither whitelisting, nor blacklisting is avaliable directly,
     we'll have implement this functionality manually. The code here is
     based in part on code I found at a now long since dissappeared url[fn:deadlink].

     The idea here is to add the [[(linumDefCustom)][missing customization]] interface
     manually during init, and to then *override* a function called
     =linum-on=.

     [2019-01-12 lör 16:23]

     This solution has become somewhat unreliable after I rewrote some
     of the logic that loads this file. However, I've amended it by also
     overriding the definition of =global-linum-mode=. Seems to work
     again. Hopefully I can stop working on this work-around when I get
     around to upgrading emacs.

     #+NAME: lit-emacs-init-linum-defcustoms
     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :noweb-ref linum-pre-26.1 :noweb yes
       (use-package linum
         :defer t
         :ensure t
         :commands (global-linum-mode linum-on)

         ;; Add new customisation options
         :preface
         <<linum-new-defcustoms>>                                     ;(linumDefCustom)

         :config
         ;; Redefine linum-on to respect our new custom
         ;; variables.
         (message "%s %s"
                  "from lit-emacs-init-linum:"
                  "overriding definition of 'linum-on'...")
         <<linum-on-redef>>                                              ;(linumRedef)

         :hook (after-init . (lambda () (global-linum-mode 1))))
     #+END_SRC

     The new customisation definitions look like this:

     #+NAME: lit-emacs-init-linum-defcustoms
     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :noweb-ref linum-new-defcustoms

       (defcustom global-linum-disabled-modes-list
         '(eshell-mode
           wl-summary-mode
           compilation-mode
           org-mode
           text-mode
           dired-mode
           doc-view-mode
           pdf-view-mode
           haskell-interactive-mode)
         "List of major modes where `global-linum-mode' shouldn't apply."
         :type '(repeat (sexp :tag "Major mode"))
         :tag "Global Linum Mode Major Mode Blacklist"
         :group 'linum)

       (defcustom global-linum-ignore-starred-buffers 't
         "If non-nil, `global-linum-mode' will ignore starred buffers such as *Gnu Emacs*."
         :type 'boolean
         :tag "Global Linum Mode Ignore Starred Buffers"
         :group 'linum)
     #+END_SRC

     And this is the overriding definition of =linum-on=:

     #+NAME: lit-emacs-init-linum-on-redef
     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :noweb-ref linum-on-redef
       (defun my-linum-on ()
         "Activate line-numbers in the current buffer, unless this
       is ruled out by `global-linum-disabled-modes-list'
       `global-linum-ignore-starred-buffers'.

       This function overrides the default definition exported in
       linum.el"
         (unless (or (minibufferp)
                     (member major-mode global-linum-disabled-modes-list)
                     (and global-linum-ignore-starred-buffers
                          (string-match "*" (buffer-name))
                          ))
           (linum-mode 1)))
       (define-globalized-minor-mode my-global-linum-mode linum-mode my-linum-on)

       (advice-add 'linum-on
                   :override
                   #'my-linum-on)

       (advice-add 'global-linum-mode
                   :override
                   #'my-global-linum-mode)

     #+END_SRC


     And that's that. Not too hard to fix, thankfully.

     WRITTEN: [2019-05-08 ons 23:13]

     This code continues to spew out warnings every time it is
     recompiled. It still seems to function just fine, but I'm becoming
     increasingly worried about the dangers of bit-rot here.


[fn:deadlink] The (now dead) link is:
=https://github.com/Khady/emacs.d/blob/master/setup-linum.el=


* Helm

  There are two (-ish) things to set up here: =helm= itself, and the
  various =helm-*= packages for interacting with other packages via
  helm.


** Main Setup

   WRITTEN [2018-10-20 lör 09:53]

   The only really noteworthy thing here is the use of =advice=,
   defined on line [[(helmCompReadAdvice)]], to make =helm= load on any use of
   =completing-read= or =read-file-name=. This ensures that those
   functions are "helm-ified" just in time, if =helm= hasn't been
   loaded already. The =advice= is removed as part of the
   =:config= step, when =helm= eventually loads.

   This setup leads to meaningless warnings from the byte-compiler
   though, which is why I claim that advice function is defined by the
   package in the =:functions= clause. It's almost true.

   Note: I'm forced to manually call =diminish= [[(helmExtraDiminish)][here]] to prevent the
   mode from getting "undiminished" by the advice. Not sure how to
   avoid that.

   #+NAME: lit-emacs-init-helm-main-setup
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"

     ;; Load helm
     (use-package helm
       ;; Load unconditionally after 5 seconds of idle time.
       :defer 5
       :ensure t
       :commands (helm-mode)
       ;; Hide the helm minor mode
       :diminish (helm-mode)
       ;; Prevent spurious warnings from the byte-compiler, by telling it a
       ;; white lie.
       :functions (my-init-completing-read-helm-advice)
       :bind (("C-s"     . helm-occur)
              ("M-x"     . helm-M-x)
              ("C-x C-f" . helm-find-files)
              ("C-x b"   . helm-buffers-list)
              ("<f6>"    . helm-execute-kmacro))
       :init
       (defun my-init-completing-read-helm-advice (&rest _args);(helmCompReadAdvice)
         "Advice for `completing-read' and `read-file-name' that
          forces `helm-mode' to activate. This advice removes itself
          from both functions when invoked. All arguments are ignored."
         (helm-mode 1)
         ;; This is neccesary, for reasons I'm not fully clear on. I guess
         ;; this function is somehow unaware of the :diminish above?
         (diminish 'helm-mode)                                  ;(helmExtraDiminish)
         (advice-remove 'completing-read
                        #'my-init-completing-read-helm-advice)
         (advice-remove 'read-file-name
                        #'my-init-completing-read-helm-advice))

       (defun my-init-completing-read-helm-advice-hook ()
         "Adds `my-init-completing-read-helm-advice' to the
          relevant functions after init."
         (advice-add 'completing-read
                     :before #'my-init-completing-read-helm-advice)
         (advice-add 'read-file-name
                     :before #'my-init-completing-read-helm-advice))

       :hook (after-init . my-init-completing-read-helm-advice-hook))

     ;; Load helm-ag
     (use-package helm-ag
           :after (helm)
           :ensure t
           :bind ("H-s" . helm-ag))

     ;; Load helm-org-rifle
     (use-package helm-org-rifle
       :after (helm org)
       :ensure t
       :bind ("H-A" . helm-org-rifle-agenda-files))

   #+END_SRC

   In addition, we could load and use =helm-dash= here, but I'm
   electing to leave that disabled (using ~:tangle no~) for now.

   #+NAME: lit-emacs-init-helm-main-dash-setup
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :tangle no
     (use-package helm-dash
       :defer t
       :after (helm)
       :ensure t
       :bind (("H-z a"   . helm-dash-activate-docset)
              ("H-z z"   . helm-dash)
              ("H-z H-z" . helm-dash-at-point)))
   #+END_SRC


** Crossover Setups

   There are a bunch of packages for interacting with other modes
   using helm. I use some of them.

   Note that all of the below declarations assume that =helm=
   autoloads are in scope. They do not, however, assume the same about
   the other packages they interact with. Hence the =:after (foo)=
   clauses.

   - =helm-flyspell=


     #+NAME: lit-emacs-init-helm-flyspell-setup
     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"

       (use-package helm-flyspell
         :defer t
         :ensure t
         :after (flyspell)
         :bind ("C-;" . helm-flyspell-correct))

     #+END_SRC

   - =helm-flycheck=


     #+NAME: lit-emacs-init-helm-flycheck-setup
     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"

       (use-package helm-flycheck
         :defer t
         :ensure t
         :after (flycheck)
         :bind ("C-c ! h" . helm-flycheck))

     #+END_SRC


   - =helm-projectile=

     It's not obvious from the code, but, *yes*, this does cause the
     =helm-projectile= keybinding remaps to come into effect just in
     time.

     #+NAME: lit-emacs-init-helm-projectile-setup
     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"

       (use-package helm-projectile
         :defer t
         :ensure t
         :commands (helm-projectile-on)
         :after (projectile)
         :init
         (eval-after-load 'projectile (lambda () (helm-projectile-on))))

     #+END_SRC


   - =helm-company=

     This adds a binding to the /active/ =company= map, which means
     the binding will be available only when a list of completions is
     visible. In other words, the binding allows me to turn a list of
     completions that is visible at the cursor into a searchable
     =helm= buffer. This is quite a handy tool to have around, should
     the list of possible completions happen to be very long.

     #+NAME: lit-emacs-init-helm-company-setup
     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"

       (use-package helm-company
         :defer t
         :ensure t
         :after (company)
         :bind (:map company-active-map
                     ("C-:" . helm-company)))

     #+END_SRC


* Org Mode

  WRITTEN: [2018-10-18 tor 13:16]

  There's little to do here, besides importing org just to define some
  symbols. The one extra package I really want is a look and feel
  thing called =org-bullets=.

  #+NAME: lit-emacs-init-org-setup
  #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :noweb yes
    ;; Some scaffolding to help control and report local fixes.
    (eval-when-compile
      (defsubst org-version-fix-msg-named(version fixname)
        (message "[init-org] applying '%s' for org-version %s" fixname version))
      (defsubst org-version-fix-msg-unnamed(version)
        (message "[init-org] applying a nameless fix for org-version %s" version))
      (defmacro org-version-fix-msg(version &optional fixname)
        (if fixname
            `(org-version-fix-msg-named ,version ,fixname)
          `(org-version-fix-msg-unnamed ,version)))
      (defmacro when-org-version-is(short-version
                                    &optional fixname
                                    &rest true-forms)
        (if (string= (org-version) short-version)
            `(progn
               (org-version-fix-msg ,short-version ,fixname)
               ,@true-forms))))

    (use-package org
        :defer t
        :ensure org-plus-contrib
        :defines (org-agenda-mode-map)
        :commands(org-extract-archive-file
                  org-all-archive-files
                  org-at-property-p
                  org-up-heading-safe
                  org-capture)
        :config
        (when-org-version-is
         "9.1.14"
         "org-all-archives-fix"
         <<org-all-archives-fix>>                            ;(Org:allArchivesFix)
         )
        <<org-config-defuns>>                                  ;(Org:configDefuns)
        :bind (:map global-map
               ("H-a" . org-agenda)
               ;; Generating links to things.
               ("H-o C-s" . org-store-link)
               :map org-mode-map
               ;; Narrowing and navigation.
               ("H-n f" . org-narrow-to-subtree)
               ("H-n t" . my-org-narrow-to-top-level-tree)
               ("H-n F" . org-narrow-to-defun)
               ("H-n e" . org-narrow-to-element)
               ("H-n b" . org-narrow-to-block)
               ("H-M-<up>" . org-previous-visible-heading)
               ("H-M-<down>" . org-next-visible-heading)
               ;; Clocking
               :map global-map
               ("H-o c l" . org-clock-in-last)
               ("H-o c o" . org-clock-out)
               ("H-o c q" . org-clock-cancel)
               ("H-o c j" . org-clock-goto) ;; Jump to currently clocked in heading
               ;; Capture
               ("H-o a" . org-capture) ;a as in "add"
               :map org-mode-map
               ("H-o c i" . org-clock-in)
               ("H-o c d" . org-clock-display)
               :map org-src-mode-map
               ("H-n f" . narrow-to-defun))
        :hook (org-mode . (lambda ()
                            (setq-local my-page-sep-special-prefix
                                        "* COMMENT"))))

    ;; So I won't have to keep staring at rows of asterisks.  Plus it
    ;; makes deeply nested trees (slightly) easier to deal with.
    (use-package org-bullets
      :defer t
      :commands org-bullets-mode
      :after org
      :ensure t
      :hook (org-mode . (lambda () (org-bullets-mode 1))))

  #+END_SRC



  WRITTEN: [2018-10-26 fre 10:06]

  Line [[(Org:allArchivesFix)]]: I had to add a fix for a bit of broken
  code in my current =org= version. Will need to file a bug report
  about this. See the heading [[*Fix: =org-all-archive-files= is broken
  in 9.1.14]] below for the actual body of the fix.


  WRITTEN: [2018-11-02 fre 09:03]

  Line [[(Org:configDefuns)]]: I've decided to add some personalised helper
  functions here, which I'm electing to define in a [[*Personal =org= Functions][node below]].

** Fix: =org-all-archive-files= is broken in 9.1.14

   The mistake was due to a use of =eq= for string comparison on line
   [[(allArchiveStringEqFix)]]. The original line is commented out just
   above it.

   #+NAME: öot-emacs-init-org-archive-all-files-fix
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :tangle no :noweb-ref org-all-archives-fix
     ;; Copied from org-archive.el.
     ;; Modified to use the correct string comparison function.
     (defun my-org-all-archive-files ()
     "Get a list of all archive files used in the current buffer.

     This overrides the standard definition, to fix a mistaken use of
     `eq' for string equality in `org-all-archive-files' in version
     9.1.14 of `org'.  The mistake caused the function to fail to
     recognise :ARCHIVE: org properties, and thus to ignore archive
     files specified in such properties.

     This redefinition replaces the bad `eq' call with a call to
     `string=', which fixes the problem, and restores the expected
     behaviour."
     (let ((case-fold-search t)
       files)
       (org-with-wide-buffer
        (goto-char (point-min))
        (while (re-search-forward
            "^[ \t]*\\(#\\+\\|:\\)ARCHIVE:[ \t]+\\(.*\\)"
            nil t)
          (when (save-match-data
                  ;; CHANGED PART HERE
                  ;; Was: (if (eq (match-string 1) ":") (org-at-property-p)
                  (if (string= (match-string 1) ":") (org-at-property-p) ;(allArchiveStringEqFix)
                  ;; END OF CHANGE
            (eq (org-element-type (org-element-at-point)) 'keyword)))
        (let ((file (org-extract-archive-file
                 (match-string-no-properties 2))))
          (when (and (org-string-nw-p file) (file-exists-p file))
            (push file files))))))
       (setq files (nreverse files))
       (let ((file (org-extract-archive-file)))
         (when (and (org-string-nw-p file) (file-exists-p file))
       (push file files)))
       files))

     (advice-add 'org-all-archive-files
              :override
              #'my-org-all-archive-files)
   #+END_SRC

** Personal =org= Functions

   These are loaded during the =:init= or =:config= portions of the
   =use-package= declaration for [[*Org Mode][=org=]] above.

   Firstly, I'd like a narrowing function that narrows to the current
   top-level tree.

   #+NAME: lit-emacs-init-org-config-defuns
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :tangle no :noweb-ref org-config-defuns
     (defun my-org-narrow-to-top-level-tree(&optional parent)
       "Widen, and narrow to the root of the current tree. If prefix
     arg PARENT is non-nil, narrow to the parent of the current node
     instead of the root of the tree."

       (interactive "P")
       (widen)
       (save-excursion
         (if (null parent)
             ;; Return to the root
             (while (org-up-heading-safe))
           ;; Move to parent
           (org-up-heading-safe))
         ;; When we''ve arrived:
         (org-narrow-to-subtree)))

   #+END_SRC

** Agenda Functions

   WRITTEN: [2018-10-17 ons 19:00]

   There are a couple of functions that need defining here, mainly for
   =org-agenda= use.

*** My agenda setup

    Firstly, I need a pair of helpers, [[(delBeforeShow)][one]] to clear the frame before
    opening the agenda, and [[(indirectHack)][one]] to give me a key binding for closing
    indirect buffers opened via an agenda view.

    #+NAME: lit-emacs-init-agenda-split-helpers-def
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :tangle no :noweb-ref org-agenda-helpers

      ;; Helper function for my-agenda-split-settings, defined further
      ;; down. Clears the frame of other buffers/windows before opening the
      ;; agenda in the current one.
      (defun my-agenda-del-before-show (&optional fe)             ;(delBeforeShow)
        "Like 'agenda-mode-show' but delete other buffers first."
        (interactive)
        (delete-other-windows)
        (org-agenda-show fe))

      ;; Tiny function to help close an indirect buffer opened from an
      ;; agenda buffer. Used in my-agenda-split-settings below.
      (defun my-agenda-del-indirect-hack ()                        ;(indirectHack)
        "Delete the window below, if it exists."
        (interactive)
        (when (with-demoted-errors "No valid buffer below! (Exact error: %s)"
                (windmove-down))
          (delete-window)))

    #+END_SRC

    And in addition, I
    need one tiny hook to make =org-agenda-mode= split windows in a
    way that I don't find deeply upsetting.

    #+NAME: lit-emacs-init-agenda-split-settings-def
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :tangle no :noweb-ref org-agenda-helpers
      ;; Adjust some agenda settings on the fly, when the mode is loaded.
      (defun my-agenda-split-settings ()
        "Set buffer-local split thresholds in agenda mode.
      Specifically: set 'split-height-threshold' to nil and
      'split-width-threshold' to 5.  Also redefines the goto key and
      switch to key."
        (interactive)
        (setq-local split-height-threshold nil)
        (setq-local split-width-threshold 5))
    #+END_SRC

    Armed with those, I can define setup the agenda to my liking:

    #+NAME: lig-emacs-init-agenda-agenda-split-settings-def
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :noweb yes
      (use-package org-agenda
        :defer t
        :ensure org

        ;; Needed for autoloading, and making the byte-compiler happy.
        :commands (org-agenda-show
                   org-agenda-redo)

        ;; Define helpers and hooks
        :init
        <<org-agenda-helpers>>

        :bind (:map org-agenda-mode-map
               ("RET"          . my-agenda-del-before-show)
               ("<return>"     . my-agenda-del-before-show)
               ("C-RET"        . org-agenda-goto)
               ("<C-return>"   . org-agenda-goto)
               ("C-M-RET"      . org-agenda-switch-to)
               ("<C-M-return>" . org-agenda-switch-to)
               ("<tab>"        . org-agenda-tree-to-indirect-buffer)
               ("<backtab>"    . my-agenda-del-indirect-hack))

        :hook (org-agenda-mode . my-agenda-split-settings))

      ;; Add the above to the agenda-mode-hook.
      ;(add-hook 'org-agenda-mode-hook 'my-agenda-split-settings)

     #+END_SRC


*** Agenda view opening functions

    Some functions which mimic the agenda key bindings connected to
    two agenda views I make frequent use of.

    #+NAME: lit-emacs-init-agenda-view-open-functions-def
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"

      ;; Open the views in question

      (defun my-agenda-custom-view-general (&optional arg)
        "Show the ;; view, passing along optional ARG."
        (interactive "P")
        (org-agenda arg ";;"))

      (defun my-agenda-custom-view-work (&optional arg)
        "Show the ;W view, passing along optional ARG."
        (interactive "P")
        (org-agenda arg ";W"))


      ;; Open and bury

      (defun my-agenda-custom-view-general-and-bury (&optional arg)
        "Show the ;; view, passing along optional ARG, then bury the buffer."
        (interactive "P")
        (org-agenda arg ";;")
        (bury-buffer))


      (defun my-agenda-custom-view-work-and-bury (&optional arg)
        "Show the ;W view, passing along optional ARG, then bury the buffer."
        (interactive "P")
        (org-agenda arg ";W")
        (bury-buffer))

    #+END_SRC


*** Idle timers

    I like having =emacs= construct my agenda buffers for me, if I'm
    ever idle (in emacs) for significant periods of time.

    #+NAME: lit-emacs-init-agenda-timers-setup
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      ;; Show work or general agenda depending on current date/time.
      (defun my-show-agenda-special (&optional arg)
        "Show the work or general agenda depending on the weekday and
      current time, passing ARG along as appropriate."
        (deactivate-mark)
        (let ((dayOfWeek (string-to-number (format-time-string "%u")))
              (timeOfDay (string-to-number (format-time-string "%H"))))
          (if (or (= dayOfWeek 6)
                  (= dayOfWeek 7)
                  (< timeOfDay 7)
                  (> timeOfDay 17))
              (my-agenda-custom-view-general arg)
            (my-agenda-custom-view-work arg)))
        (goto-char (point-min)))


      ;; Show/Update agenda every 2 minutes after an initial period of 5
      ;; minutes of idleness.
      (defvar my-agenda-idle-update-resume-timer nil
        "Timer for `my-agenda-idle-maybe-update' to reschedule itself, or nil.")

      (defun my-agenda-idle-update ()
        "Run `org-agenda-redo' every 2 minutes, if idle.

      Stop doing this after 6 hours of idleness"

        (when my-agenda-idle-update-resume-timer
          (cancel-timer my-agenda-idle-update-resume-timer))

        ;; Display agenda.
        (let ((target-frame (car (visible-frame-list))))
          (if (null target-frame)
              (message "update-agenda-idle-timer: no visible frames; skipping update")
            ;; Not sure if I need to do this, but I might as well.
            (raise-frame target-frame)
            (message "update-agenda-idle-timer: updating agenda..")
            (my-show-agenda-special)
            (when org-agenda-sticky
              (org-agenda-redo))))

        ;; Don't reschedule if it's been more than 6 six hours.
        (unless (time-less-p (seconds-to-time (* 6 3600))
                             (current-idle-time))

          (let ((timeincr (if (time-less-p (seconds-to-time (* 2 3600))
                                           (current-idle-time))
                              ;; if it's been more than two hours: update
                              ;; once every 15 min.
                              (* 15 60)
                            ;; else: update every 2 minutes
                            120)))

            (setq my-agenda-idle-update-resume-timer
                  (run-with-idle-timer
                   (time-add (current-idle-time) timeincr)
                   nil
                   #'my-agenda-idle-update)))))

      ;; Starts after 5 minutes.
      (run-with-idle-timer 300 t #'my-agenda-idle-update)
    #+END_SRC

* Templating Functionality
** =yasnippet=

   Setting up =yasnippet= itself, along with =auto-yasnippet= is
   straight forward:

   #+NAME: lit-emacs-init-yasnippet-setup
   #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
     ;; yasnippet
     (use-package yasnippet
       :diminish yas-minor-mode
       ;; Load eagerly, this needs to be active, and fail fast if it's
       ;; broken. Snippets are loaded just in time, anyway.
       :demand t
       :ensure t
       ;; Bindings copied from jweigley's dot-emacs.
       :bind (("C-c y d" . yas-load-directory)
              ("C-c y i" . yas-insert-snippet)
              ("C-c y f" . yas-visit-snippet-file)
              ("C-c y n" . yas-new-snippet)
              ("C-c y t" . yas-tryout-snippet)
              ("C-c y l" . yas-describe-tables)
              ("C-c y g" . yas-global-mode)
              ("C-c y m" . yas-minor-mode)
              ("C-c y a" . yas-reload-all)
              ("C-c y x" . yas-expand))
       :config
       (yas-global-mode 1))

     ;; aya
     (use-package auto-yasnippet
       :defer t
       :ensure t
       :after (yasnippet)
       :bind (("H-w" . aya-create)
              ("H-y" . aya-expand)))

     ;; helm source for yasnippet
     (use-package helm-c-yasnippet                             ;(helmCYasnippetLoad)
       :defer t
       :ensure t
       :after (helm yasnippet)
       :bind ("C-c y :" . helm-yas-complete))

   #+END_SRC

*** TODO Add a binding for =helm-c-yasnippet=?

   The package is loaded [[(helmCYasnippetLoad)][here]], but I don't have a specific binding set
    up to use it. May be worth considering.


** =yatemplate=

   I've elected to put this under it's own heading, as it requires some
   specific setup. =yatemplate= basically combines ~auto-insert~ with
   ~yasnippet~, allowing you to have file templates with ~yasnippet~
   code inside them.

*** TODO Checking the templates

    Firstly, I'd like to have a function to check that the template
    directory exists, and that the templates within it have reasonable
    names. =yatemplate= prefers templates to have names of the form

        #+NAME: lit-emacs-init-yatemplate-filename-grammar
        #+BEGIN_VERBATIM

        <TEMPLATE_NAME> := <NUMBER><SEP><REGEX_NAME>

        <NUMBER> := {x | x matches '[0-9]+'}

        <COLON>  := <VAR:yatemplate-separator>

        <REGEX_NAME> := { "valid regex that doesn't end with a '$' character" }
        #+END_VERBATIM

     where

     - =x matches '[0-9]+'= should be understood to mean "x matches the
       regular expression =[0-9]+="

     - =<VAR:foo>= should be understood to mean "the value of the
       variable 'foo' in emacs"


     and the definition of =<REGEX_NAME>= is hopefully
     self-explanatory.

     So lets check write such a function. Here's a very basic version:

     #+NAME: lit-emacs-init-check-yatemplate-dir-def
     #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)" :tangle no
       (defun nilgu/check-yatemplate-dir ()
         "Verify that the template dir exists and contains reasonable files.
       This entails checking that the directory exists, that the files within
       have reasonable names, and that those files are actual text files.

       Note: This won't catch malformed regex sequences in filenames."
         (let ((warnprfx "from lit-emacs-init-templating:"))
           (if (file-directory-p yatemplate-dir)
               ;; It's a directory
               (let ((badfiles (seq-filter
                                (not (string-match-p
                                      (format "[0-9]+%c.+[^$]" yatemplate-separator)))
                                (directory-files yatemplate-dir))))
                 ;; If one or more files are malformed
                 (unless (null badfiles)
                   (mapc (lambda (x)
                           (message
                            (format
                             "%s found malformed filename in yatemplate-dir: %s"
                             warnprfx
                             x)))
                         badfiles)))
             ;; It's not a directory
             (message
              (format
               "%s the value of yatemplate-dir, '%s', isn't a directory!"
               warnprfx
               yatemplate-dir)))))
     #+END_SRC

     Not fully satisfied with this, as it doesn't handle the filenames
     quite right. We should split on the first instance of
     ~yatemplate-separator~, and /then/ attempt a regex match.

     A more sensible approach might be to add a function that verifies
     that all of ~auto-insert-alist~ is well formed after populating
     it, rather than checking the filenames themselves.

     Leaving this untangled for now.

*** Setup

    The package itself is easy to load:

    #+NAME: lit-emacs-init-yatemplate-setup
    #+BEGIN_SRC emacs-lisp +n -r -l ";(%s)"
      (eval-and-compile (defun what-happening()
          (message "this ran")
          (yatemplate-fill-alist)))

      (use-package yatemplate
        :defer 15
        :ensure t
        :commands yatemplate-fill-alist
        :init
        (eval-after-load 'autoinsert
          #'yatemplate-fill-alist))
    #+END_SRC

    The above setup runs on an ~after-init-hook~, because the behaviour
    depends on variables acquired from the =custom= file.
